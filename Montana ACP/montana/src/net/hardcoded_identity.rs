//! ML-DSA-65 identity verification for hardcoded nodes

use crate::crypto::mldsa::{verify_mldsa65, MlDsa65PublicKey, MlDsa65Signature};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::sync::LazyLock;

/// Challenge size in bytes (256 bits of entropy)
pub const CHALLENGE_SIZE: usize = 32;

/// Challenge nonce for authentication
pub type Challenge = [u8; CHALLENGE_SIZE];

/// Hardcoded node identity: IP address bound to public key
#[derive(Debug, Clone)]
pub struct HardcodedNode {
    /// Socket address (IP:port)
    pub addr: SocketAddr,
    /// ML-DSA-65 public key (1952 bytes)
    pub pubkey: MlDsa65PublicKey,
    /// Human-readable identifier
    pub name: &'static str,
    /// Geographic region
    pub region: &'static str,
}

// =============================================================================
// MAINNET HARDCODED NODES
// =============================================================================
//
// Each entry binds an IP address to a cryptographic public key.
// Operators must sign challenges with corresponding private keys.
//
// To add a new hardcoded node:
// 1. Generate ML-DSA-65 keypair: `montana keygen --type mldsa65`
// 2. Submit public key to Montana maintainers
// 3. Store private key securely (HSM recommended)
// 4. Configure node to sign challenges on port 19333

/// Mainnet hardcoded nodes with verified public keys
pub static MAINNET_HARDCODED: LazyLock<Vec<HardcodedNode>> = LazyLock::new(|| {
    vec![
        // TimeWeb Primary (Moscow)
        // Operator: Montana Foundation
        HardcodedNode {
            addr: SocketAddr::new(IpAddr::V4(Ipv4Addr::new(176, 124, 208, 93)), 19333),
            pubkey: TIMEWEB_MOSCOW_PUBKEY,
            name: "timeweb-moscow-1",
            region: "eu-east",
        },
        // Additional nodes to be added as network grows
        // Each requires verified public key from operator
    ]
});

/// Testnet hardcoded nodes
pub static TESTNET_HARDCODED: LazyLock<Vec<HardcodedNode>> = LazyLock::new(|| {
    vec![
        HardcodedNode {
            addr: SocketAddr::new(IpAddr::V4(Ipv4Addr::new(176, 124, 208, 93)), 19334),
            pubkey: TIMEWEB_MOSCOW_PUBKEY,
            name: "timeweb-moscow-testnet",
            region: "eu-east",
        },
    ]
});

// =============================================================================
// PUBLIC KEYS
// =============================================================================
//
// ML-DSA-65 public keys (1952 bytes each)
// Generated offline, submitted by operators

/// TimeWeb Moscow public key
/// Generated: 2026-01-07 19:09:21 UTC
/// Operator: Montana Foundation
/// IP: 176.124.208.93
const TIMEWEB_MOSCOW_PUBKEY: MlDsa65PublicKey = *b"\x03\xcf\xfe\xe6\x1f\xcc\x4e\x84\xfd\x3f\x87\xde\x01\xc1\x78\x23\x3c\xe1\x66\x24\x28\x1f\xed\x73\xcb\x84\xb1\x04\x1c\x52\x74\x41\xcf\x2d\xe6\x38\x2b\xe1\x48\x85\xd9\x20\x87\xb0\xf3\x06\x29\xfb\x06\x40\x69\x37\x2e\x11\x9b\xe0\x9b\x28\xc9\x4f\x55\x62\x4b\x9b\xee\x12\x44\x2d\x04\xd6\x8f\xce\x08\xaf\xf6\xb8\x4d\x1c\xa1\xff\x8c\x39\x73\x3e\xc3\x88\x78\x9b\x8f\xe0\x6f\x13\xbb\x97\x8a\x62\xd0\xa8\x04\x88\x5c\x46\xd4\x75\x86\xc9\x75\xc2\x9b\x0d\x2e\x66\x76\x57\x5c\x70\x73\xd5\x79\x29\x90\x3b\x60\xed\x15\x73\xe6\x4e\x0c\x62\x5f\x4e\x77\xd6\x3c\x26\xac\x2f\xa1\xcc\x50\xa8\xdc\x4c\xed\xb4\x5b\xe9\xa0\xbe\x1a\x6d\x38\xf0\x00\xcd\xa7\x05\x68\x48\x33\x00\xd7\x6d\x25\x47\x49\x77\xba\x26\x07\x5c\x10\x31\xfe\x08\x4d\x47\x08\x25\x9d\x34\x3d\x13\xe7\x88\x85\xca\xe8\xb0\x50\xa4\x74\x1f\x0f\x22\x6a\x46\x5b\x29\xce\x99\xc5\x7b\x14\x31\x8e\xc1\xdc\x19\x7c\xb4\x5d\x26\x51\x39\xa1\xd5\x1f\xc6\x3e\xc2\xd4\xdc\x96\xb8\x6e\x08\xc0\x58\x85\x5a\x8c\x92\x52\xb1\x0b\xde\xdf\x44\xc0\x9e\xe4\x83\xd7\x3d\x41\x06\x76\xc2\x55\x76\x05\xc8\xc1\xfc\x48\x54\xca\x99\xf2\x87\x6a\x07\xad\x39\x81\xc4\x15\x4b\xac\xa1\x34\xe6\xc7\xea\x6f\x91\x9a\x46\xc3\xe3\xf9\x63\x8f\x20\xd1\x8e\x21\xfc\xe9\x6f\x33\xd0\xa1\xeb\x6a\xc7\x65\x76\xaf\x74\x32\xaf\x94\xe2\xee\xf2\x4c\x8d\x71\x8b\xeb\xb4\xce\x91\x50\xb0\xe9\x9e\x8f\x83\x4c\xe7\x4f\xce\x30\x4f\xbf\xdb\x9e\xe4\xc4\x51\x5f\x4a\x0c\xd6\x9d\xe7\xfc\x77\x3e\x54\x28\xb9\x5c\x8f\xd2\x29\x5d\xb8\x96\x23\xce\x9a\x21\xb8\x34\xa2\x2d\x96\xe9\x94\x2d\x19\xd4\x9a\xc4\xa6\x7f\x98\x48\xe0\x06\xf5\x93\x78\xa5\xb2\x85\xac\xfd\x07\x8b\xf3\x6d\x3a\x61\x14\x48\xa5\x4c\x3d\xbd\xe5\xd6\x9c\x40\x32\x43\x23\x5c\x50\x2a\x25\xec\xb7\xdb\x5e\x5e\xe2\x07\xc5\x55\x9a\x32\xf6\x89\x3a\xcd\x59\xad\xd3\x5e\xcb\x92\xfe\xab\x41\x42\x56\xcb\x24\x17\x97\x4b\x15\x74\x9d\x86\x87\x30\x1a\x42\x0e\xd4\xbc\x49\x03\x70\x3c\x49\x62\xa8\x8b\x2d\x9c\xa2\xc6\x6d\x88\x0e\x50\x2c\xc8\x64\xac\xa8\x21\xd7\x88\xb2\xf9\x8f\xde\x18\x5d\x7a\xe4\x60\xf7\x67\x7a\x5d\xbd\x6d\xab\x73\x2e\x85\x1f\x6c\xe3\x10\x94\xe7\x61\xe5\x62\xfc\xdc\x23\x88\x02\xbd\x88\x0b\xc9\xae\x79\xe7\x50\xc9\x44\x78\xcd\xa3\xc1\xfe\x02\x77\xce\x39\x37\x0b\x44\xab\x89\xbd\x77\x7a\xee\x11\xdd\x73\x50\x2b\xf5\x1a\x00\x14\x1d\xc1\x83\xa9\x68\x1b\x1f\x89\xc0\xb1\xeb\x02\xf6\x92\xc4\x54\x8e\xce\xca\x0f\x24\x99\x9a\xa2\x15\x8c\x59\x7b\x00\x67\x29\xb5\x76\xed\xb1\xe0\xea\x84\xc6\x1a\x5f\x9e\xb4\x86\xc6\x2c\x74\x65\xa5\x4a\x07\xd6\x9b\xec\xf4\x39\x10\x31\x10\xd2\x57\x40\xaa\x80\x8a\x96\x6a\x6f\x84\x45\x3a\x14\x54\xb6\xc7\x17\x7b\xfd\x44\x95\xba\x3c\x07\x69\x24\x20\xf5\xb7\xee\x93\x2c\x08\xd4\xcc\x6a\x11\x36\x93\xca\x73\x6e\xec\xd8\x2a\xef\xa7\xf5\x0c\x36\xbd\x33\xda\xb1\xc2\x67\xa9\xda\x21\x94\x4c\x69\x50\xda\x06\x6f\x0d\x15\xf1\xd6\x00\x94\x3b\x6c\x77\x09\x95\x7e\x47\x3c\xed\xb9\x92\xcc\x87\x49\x3d\xe3\xaa\xf7\xaa\x65\x3f\x01\xca\x93\xf5\x50\x35\xad\xce\x13\xcd\x90\xd5\x41\xc8\xe4\x2c\x9d\x5c\x3d\xbd\x54\xc3\x98\x36\x99\xca\x61\x7f\x40\xb9\xa7\xbd\x7d\xe8\x65\xd3\x74\x8f\x62\x74\xd9\xf9\x95\x1b\x17\xbb\x5d\x0e\x12\xe4\x1b\xc7\x19\x11\xdf\x2d\xa2\xea\x5e\x0c\x71\xad\x8d\x98\xdd\xdc\x72\xc4\xfa\x07\x6c\x7d\xb3\xe8\x0f\x67\x20\xb6\x97\x6a\xe5\x9d\xbe\xf9\xab\xc8\x80\xd2\xae\xac\xe4\xb6\xc6\x8a\xe1\x66\x34\xba\xcd\xd9\x73\x6e\xde\x96\x1d\x0d\xa1\x6b\x3e\x1f\xd6\xda\x4e\x8f\x3d\x70\x8b\x7f\xf6\xd0\x6c\x58\x19\xaa\x10\xe5\x67\x34\x18\xb4\x0b\x2c\x0c\x78\x66\x01\xd7\x23\xbb\x55\x2b\x26\xb7\xf1\x38\xba\xe3\xf8\x38\x37\x36\x17\x90\x34\x23\xaa\xf0\x9c\xfb\xad\x2e\xf4\x23\xa9\xc3\xde\xcb\xd5\xe2\x00\x55\x04\x16\x06\x9d\xb3\x99\x83\xcd\x46\x30\x6a\xe2\x7d\x6e\xcc\xde\x6b\xef\xf0\x74\x9a\x7e\x5f\x25\xaa\x66\xc6\x4c\xaf\xf8\x80\x98\x4b\x75\x56\x96\x3f\x70\xb5\xc8\x9f\x13\xcd\xa8\x26\xb8\x7b\x1b\x13\xed\x45\xff\x64\x3c\x7a\x06\x8f\xba\x18\xd6\x7e\x08\x9b\x09\xa2\x47\x57\x16\x7b\xc5\x84\x6b\xcf\x90\x99\x51\x3e\x24\xe3\xae\x86\x1c\x72\x93\xf3\xac\x86\x7d\x87\xd4\x77\xeb\xdb\x51\x8f\x06\x3c\x7f\x62\x57\x7a\xae\x43\x71\xcc\xb1\x54\xc9\x7e\x55\xfe\x23\xee\x44\xd5\xb2\xf3\x10\xca\xe6\x87\x5a\xe6\x44\xbd\xf8\x02\x2c\xf5\x9e\x58\x2e\x52\x6b\x69\xf0\x79\x1e\xa5\xdb\xb8\xd3\x82\xad\x21\x58\x4d\xd4\x13\x9f\x01\xec\xdb\x54\x06\xbd\xb5\xea\x46\x98\xe7\xec\x1e\xbe\xe0\x11\xbd\xc9\x1a\x18\x50\x1f\xf6\xc2\xde\xff\x81\x6a\x8e\x69\xcc\x17\xcb\x26\x6e\x8b\x8b\x74\x4c\x3a\x25\x3f\xe0\x3c\xdc\x83\x53\xda\x72\x71\x65\x6c\xb9\x3c\x66\x42\xb3\x98\x05\xee\x3a\xf0\x34\xcd\x5f\xb0\xcb\x9d\x08\x99\xf4\xdb\xc5\x78\x34\x78\x4c\x0d\x3b\x73\x06\xcb\xa0\xa9\x32\x1d\x9a\x11\x1f\x39\x3c\x82\xae\x76\x08\xed\x51\xea\xbc\x09\x46\xab\x97\x2e\xbd\x10\x4a\xde\x13\x6e\xd5\xbd\xa6\xcb\x95\x73\x07\x98\x31\xec\x4f\xeb\x79\x70\xf6\xd2\xda\x49\x49\xd0\xcd\x36\x73\x00\x28\x20\x4b\xa1\xb0\xfa\x58\x77\xcc\x84\x0a\x07\xcc\xf2\x3b\x08\x76\xa3\xba\x45\xce\xd3\xa1\x3e\x3d\xb3\xbe\x59\x71\xa4\x9a\xee\xfc\x54\x78\x9a\x51\x6c\x6a\x60\x5d\x0d\xb8\x5f\x8d\x09\x6d\x57\x33\x6c\x11\x5e\x49\x98\xfb\x10\x82\xde\x79\x1c\x92\x05\xa2\x58\x45\xbd\x95\xcc\x42\x2e\x59\xb1\xdf\x59\x94\xaf\xf1\xb4\x45\x29\xc3\x7a\x1f\xcd\xf4\x2c\xe7\x6b\xaa\xad\xbd\x3a\x20\x16\x87\x18\xf4\x89\xf1\x9e\x7f\x55\x65\x86\x23\xb6\x64\xf3\x2c\x9a\xd0\x74\xa1\xb8\x71\x95\x86\x97\xea\x2e\xd8\x9e\xe2\xa5\x7e\x8d\x36\xe2\x7d\x63\x5d\x40\xd5\x99\xdb\x09\xdc\x14\x44\x70\x39\x60\xa1\x87\x3e\x9d\x38\xd3\xf4\x1e\x09\xf4\xf7\xea\x84\xa6\x3f\xa1\x67\xa4\xed\x53\xfd\x54\xa5\x80\x9f\x17\xe8\x7f\xc3\xe3\x2f\xf5\xd9\x9b\x86\xaf\x8c\x3c\x24\x20\x40\x37\x64\x64\x16\x86\x7c\xef\xf0\x42\x52\xef\xe3\x79\x42\xf0\x04\x0a\x77\x09\x9a\x89\xd0\x3f\x6d\x86\x24\xb0\x01\x3f\x3d\xec\x42\x22\x2f\x33\xc9\xa8\x5f\xe7\x49\xca\xfa\xa3\x5e\x88\x5b\xda\x34\x3a\x44\x78\x7c\xfe\x55\x15\x32\x9b\x42\x62\xbd\x26\x82\xb1\x50\x37\x08\xff\x05\xd5\xdf\x0c\xb2\x3c\xf6\x9f\x90\xd9\xe3\xb0\x91\x99\x2f\xbd\xf4\xd6\x30\x0b\x74\x06\x74\xdc\x78\xab\xd5\x9c\xcb\x99\x6f\x3c\x2f\x12\x03\x57\xc5\x1b\x1a\x9b\x38\x35\xcb\xc5\xaf\xce\x38\x09\x5f\xfd\x63\x0c\x18\x20\x3f\xbe\xb7\x5e\x0f\x35\x55\x7e\x60\xfa\x1d\x08\x6f\xcb\xba\x06\x93\x41\xab\x51\xca\x39\xb1\x28\x4b\x9a\xa4\x02\xa3\xf1\xae\xb4\x1a\xbc\x99\xa7\x8d\x3f\x92\xc8\x30\xa6\x2f\xeb\x73\x37\x1d\x96\xef\x28\x07\x14\x29\x50\x4d\x94\x30\x66\x42\xde\x73\x22\xbf\xb6\x6f\xfb\xf3\x03\x69\x11\xc2\x18\xfc\x78\x16\x51\xe4\x39\x14\xbd\x35\x0c\xba\x7d\xd9\xea\x93\x1b\x2e\x30\xe2\xf6\x0a\xed\x96\xd9\xf5\x60\x06\x6b\x54\xb9\x36\x69\x03\x42\x2f\x0f\xcd\x63\xb9\x8c\x42\x79\xb2\xca\x9b\x49\x86\x79\x66\x26\x36\x50\x85\x12\x6e\xe8\xfc\xf4\x5f\xac\xf2\x93\xa0\xb4\x75\x26\xf0\x2b\x7a\x42\xe8\x8e\xa7\xb6\x0e\x28\xcc\x3b\xfe\xde\xd7\x63\x22\x9d\x9b\x3f\x42\x74\x87\xca\xc7\xa0\x09\x49\xf8\x6d\x8e\x1f\x62\x92\x1c\x2e\x19\x55\xf1\xca\xc5\x87\x46\x84\x08\x02\xbb\x81\xbb\x18\xb8\x17\x32\x8a\x4c\xec\xf4\x5d\x98\x05\x59\x81\x7e\xfc\x3c\x04\x03\xb5\x80\xf2\x5e\xdf\x57\xba\xdc\x75\xc0\xcf\xb7\x4d\xd0\x5c\x2e\x1a\x8e\x61\x8c\x98\xd0\x6c\xbc\x09\xf9\xc9\x23\x6e\x2c\x7a\x4e\xda\x06\x51\xa3\x38\xbb\x2d\x22\x44\xce\xc6\x85\x71\x0e\x71\xed\x31\xb1\xc8\x95\xe5\x17\x39\xa0\xb3\xe6\x03\x1f\xa9\xbd\x75\xcd\x06\x9c\xb1\xb2\x1e\xc5\x39\x9b\xb4\xe4\x0f\x4a\xc3\x94\x1b\x70\x24\xb6\x53\xeb\x8e\x0e\xa7\xec\x11\x1f\x02\xb1\x7e\xea\xbe\x9d\xb4\x39\x52\xa1\x31\xa4\x74\x15\x11\x53\x2b\xb3\x6a\x6a\xd8\xe2\xf5\x79\xa4\x01\x2b\x16\xd8\x75\xf1\x25\x4a\x7c\x98\xc8\xa2\x1c\xb5\xdd\x4a\x9e\xc2\x68\x45\xdf\x99\x87\xa8\x26\xe1\x1d\xc8\x1a\x1f\x1b\x68\xa4\x4f\x74\x3c\xf1\x5b\xb8\x72\xfe\x45\x12\xf8\x21\x76\x7e\x02\xd2\x9b\x93\x18\x69\x7b\xd9\xe4\x7c\x34\x0a\xcd\xf3\x0f\x7b\xaa\x8e\x3a\x7a\x78\xb1\x46\xcf\x7d\xb7\x40\x47\x82\x77\x76\x38\xcf\xc5\x89\x37\x43\x81\x78\x02\x97\xd5\x83\xf9\xe2\x2d\xd0\xe3\xe1\x95\x26\x58\x19\x24\x28\xc5\x52\x3e\xc5\x07\x7a\xa9\x8d\x63\x85\x0a\x8b\x28\x83\xa2\x86\xa3\xa0\xe2\x89\x1c\x67\x8e\xe0\xef\xf0\xe4\xc5\x4e\xca\xca\x2c\xb2\x2c\x73\x13\x41\x78\x6a\xba\xcc\x66\xa8\x9b\xe7\x3d\xc0\xe5\x27\x5d\x3e\x89\xe0\x92\xbf\x5c\xfb\x17\x64\x5e\xf2\x2c\x32\x47\x84\xfc\x6d\x88\xa7\x9c\xa7\x0b\x64\xce\x1d\x81\x99";

// =============================================================================
// VERIFICATION
// =============================================================================

/// Verify challenge-response signature from hardcoded node
pub fn verify_hardcoded_response(
    addr: &SocketAddr,
    challenge: &Challenge,
    signature: &MlDsa65Signature,
    testnet: bool,
) -> Result<(), HardcodedAuthError> {
    // Get expected public key for this address
    let nodes = if testnet {
        &*TESTNET_HARDCODED
    } else {
        &*MAINNET_HARDCODED
    };

    let node = nodes
        .iter()
        .find(|n| &n.addr == addr)
        .ok_or(HardcodedAuthError::UnknownNode(*addr))?;

    // Domain separation: must match signing format in protocol.rs
    // Format: "Montana.Auth.v1.<network>.<challenge>"
    let network = if testnet { b"testnet" } else { b"mainnet" };
    let mut msg = Vec::with_capacity(32 + 32);
    msg.extend_from_slice(b"Montana.Auth.v1.");
    msg.extend_from_slice(network);
    msg.push(b'.');
    msg.extend_from_slice(challenge);

    // Verify signature
    if !verify_mldsa65(&node.pubkey, &msg, signature) {
        return Err(HardcodedAuthError::InvalidSignature {
            addr: *addr,
            name: node.name,
        });
    }

    Ok(())
}

/// Check if address is a known hardcoded node
pub fn is_hardcoded_addr(addr: &SocketAddr, testnet: bool) -> bool {
    let nodes = if testnet { &*TESTNET_HARDCODED } else { &*MAINNET_HARDCODED };
    nodes.iter().any(|n| &n.addr == addr)
}

/// Get all hardcoded addresses
pub fn get_hardcoded_addrs(testnet: bool) -> Vec<SocketAddr> {
    let nodes = if testnet { &*TESTNET_HARDCODED } else { &*MAINNET_HARDCODED };
    nodes.iter().map(|n| n.addr).collect()
}

/// Get expected public key for hardcoded address
pub fn get_hardcoded_pubkey(addr: &SocketAddr, testnet: bool) -> Option<&'static MlDsa65PublicKey> {
    let nodes = if testnet { &*TESTNET_HARDCODED } else { &*MAINNET_HARDCODED };
    nodes.iter().find(|n| &n.addr == addr).map(|n| &n.pubkey)
}

/// Get hardcoded node info
pub fn get_hardcoded_node(addr: &SocketAddr, testnet: bool) -> Option<&'static HardcodedNode> {
    let nodes = if testnet { &*TESTNET_HARDCODED } else { &*MAINNET_HARDCODED };
    nodes.iter().find(|n| &n.addr == addr)
}

/// Get all hardcoded nodes
pub fn get_hardcoded_nodes(testnet: bool) -> &'static [HardcodedNode] {
    if testnet { &*TESTNET_HARDCODED } else { &*MAINNET_HARDCODED }
}

/// Minimum hardcoded responses required (75%)
pub fn min_hardcoded_responses(testnet: bool) -> usize {
    let total = if testnet {
        TESTNET_HARDCODED.len()
    } else {
        MAINNET_HARDCODED.len()
    };
    (total * 75 + 99) / 100 // ceil(75%)
}

// =============================================================================
// ERRORS
// =============================================================================

#[derive(Debug, thiserror::Error)]
pub enum HardcodedAuthError {
    #[error("unknown hardcoded node: {0}")]
    UnknownNode(SocketAddr),

    #[error("invalid signature from {name} ({addr})")]
    InvalidSignature {
        addr: SocketAddr,
        name: &'static str,
    },

    #[error("challenge mismatch")]
    ChallengeMismatch,
}

// =============================================================================
// TESTS
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hardcoded_addrs_not_empty() {
        let addrs = get_hardcoded_addrs(false);
        assert!(!addrs.is_empty(), "mainnet must have hardcoded nodes");
    }

    #[test]
    fn test_is_hardcoded() {
        let timeweb = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(176, 124, 208, 93)), 19333);
        assert!(is_hardcoded_addr(&timeweb, false));

        let unknown = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(1, 2, 3, 4)), 19333);
        assert!(!is_hardcoded_addr(&unknown, false));
    }

    #[test]
    fn test_min_responses() {
        // With 1 node, need 1 (75% of 1 = 0.75, ceil = 1)
        assert_eq!(min_hardcoded_responses(false), 1);
    }

    #[test]
    fn test_get_pubkey() {
        let timeweb = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(176, 124, 208, 93)), 19333);
        let pubkey = get_hardcoded_pubkey(&timeweb, false);
        assert!(pubkey.is_some());
    }
}
