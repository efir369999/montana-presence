# Ɉ Montana

**Версия:** 11.4
**Дата:** Январь 2026
**Протокол:** Atemporal Coordinate Presence (ACP)
**Зависимости:** Слой -1 v3.2, Слой 0 v2.7, Слой 1 v1.4, Network v3.2

---

## Определение

**Ɉ** (J с двумя горизонтальными чертами, Unicode U+0248) — Temporal Time Unit.

| Атрибут | Значение |
|---------|----------|
| **Символ** | Ɉ |
| **Происхождение** | J от Junona (исходный проект, 22.08.2022) |
| **Цвет** | Золотой (#D4A84B) на чёрном (#000000) |
| **Спецификация** | `Council/doc/SYMBOL_Ɉ.md` |

**Montana** — сеть, производящая юниты времени Ɉ через протокол АКП (Атемпоральные координаты присутствия) / ACP (Atemporal Coordinate Presence).

```
lim(evidence → ∞) 1 Ɉ → 1 секунда
∀t: Trust(t) < 1

Ɉ — не просто секунда.
Ɉ — секунда, доказанная присутствием и подтверждённая сетью.
```

> **"Время — единственный ресурс, распределённый одинаково между всеми людьми."**

---

## Физическая основа (Слой -1)

Montana строится на физических инвариантах координатной структуры:

| ID | Ограничение | Роль в Montana |
|----|-------------|----------------|
| L-1.1 | Координаты упорядочены | Присутствие накапливается |
| L-1.2 | Координаты наблюдаемы | Peers + NTS аттестуют позиции |
| L-1.3 | Связь ограничена | Время передачи сообщений > 0 |
| L-1.4 | Время однородно на Земле | NTS-источники согласованы |

Полная спецификация: [layer_minus_1.md](layer_minus_1.md)

---

## Вычислительная основа (Слой 0)

Montana строится на вычислительных ограничениях:

| ID | Ограничение | Роль в Montana |
|----|-------------|----------------|
| L-0.2.2 | Подписи принимаются только для текущего τ₂ | Подписи накапливаются |
| L-0.3.2 | Хеш-коллизии сложны | SHA3-256 связывает подписи |
| L-0.3.3 | Решёточные задачи сложны | ML-DSA подписи неподделываемы |

### Примитивы

| Примитив | Стандарт | Применение |
|----------|----------|------------|
| SHA3-256 | FIPS 202 | Хеши, корни Меркла |
| ML-DSA-65 | FIPS 204 | Все подписи (присутствие, транзакции) |
| ML-KEM-768 | FIPS 203 | Обмен ключами |

### Доказательство присутствия

```
Proof(T₁...Tₙ) = {Sig(T₁), Sig(T₂), ..., Sig(Tₙ)}

Неподделываемость: L-0.3.3 (решётки)
Необратимость:     L-1.1 (координаты упорядочены)
Накопление:        L-0.2.2 (только текущий τ₂)
```

14 дней = 20,160 подписей. Каждая подпись требует реального времени.

**14 дней требуют 14 дней:**
```
Сеть синхронизирована → все узлы в одном τ₂
Подписи принимаются только для текущего τ₂
После закрытия τ₂ → presence_root зафиксирован

Атакующий с бесконечными ресурсами:
├── Может подписать 1000 координат за секунду
├── Но сеть примет только 1 подпись на минуту
└── 14 дней = 14 дней реального времени
```

### Replay protection

| Атака | Защита |
|-------|--------|
| Sig(T) для другой координаты T' | Timestamp в подписи |
| Sig(T) дважды для T | Бинарность τ₁ |
| Sig(T) для прошлого слайса | prev_slice_hash привязывает к цепи |
| Внедрить подпись задним числом | P2P-сеть требует доставку в реальном времени |

### Хранение

**Доказательство присутствия — в таймчейне:**

```
Каждый слайс τ₂ содержит:
├── presence_root: Merkle root всех подписей за этот τ₂
├── prev_hash: хеш предыдущего слайса
└── signature: ML-DSA-65 победителя лотереи

Верификация присутствия узла X:
1. Скачать таймчейн (цепь слайсов)
2. Найти слайсы где X включён в presence_root
3. Запросить Merkle proof от X
4. Проверить: proof валиден → X присутствовал
```

**Объективное доказательство:**
- presence_root подписан победителем лотереи (внешняя аттестация)
- Победитель выбран детерминистично всей сетью
- Таймчейн = публичная верифицируемая история

**Локальные чекпоинты (для pruning):**

```
Каждые τ₃ (14 дней) → Checkpoint:
├── merkle_root: SHA3-256 (32 байта)
├── presence_count: количество подписей
└── signature: ML-DSA-65

После подтверждения в таймчейне → индивидуальные подписи можно удалить
```

Чекпоинт — для экономии хранения. Доказательство — в таймчейне.

| Период | Полный размер | После pruning |
|--------|---------------|---------------|
| τ₄ (4 года) | 6.96 ГБ | 350 КБ |

**Bandwidth (пропускная способность):**

```
Full Node (получает все подписи):
├── 1000 узлов × 3309 байт/мин = 3.3 МБ/мин = 55 КБ/сек
├── 55 КБ/сек — умеренная нагрузка
└── Приемлемо для серверной инфраструктуры

Light Node (получает все подписи):
├── Тот же bandwidth что Full Node
└── Требует стабильное соединение

Light Client (получает только слайсы):
├── 1 слайс каждые 10 мин ≈ 50 КБ
├── 5 КБ/мин = 83 байт/сек
└── Работает на мобильных устройствах
```

Light Client отправляет свою подпись через P2P-сеть и получает результат лотереи.

**Транзакции:**

```
Каждые τ₂ (10 мин) → Block:
├── tx_root: Merkle транзакций
├── presence_root: Merkle подписей
└── signature: ML-DSA-65

UTXO set хранится постоянно (~2 КБ на выход)
```

| Период | Полный размер | После pruning |
|--------|---------------|---------------|
| τ₄ (4 года) | 10.5 ГБ | ~50 МБ (UTXO) |

Полная спецификация: [layer_0.md](layer_0.md)

---

## Протокольные примитивы (Слой 1)

Montana использует следующие примитивы из Слоя 1:

| Примитив | Секция | Роль в Montana |
|----------|--------|----------------|
| Детерминированная лотерея | L-1.1 | Выбор победителя τ₂ |
| Hash commitment | L-1.2 | presence_root, tx_root |
| Linked timestamp | L-1.3 | Таймчейн (хеш-цепь) |
| Hash-chain ordering | L-1.4 | Порядок слайсов, fork-choice |
| P2P-аттестация | L-1.5 | Доказательство присутствия |

### Детерминированная лотерея

```
seed = SHA3-256(prev_slice_hash ‖ τ₂_index)

Stage 1: seed mod 100 → пул (Full/Light/Client)
Stage 2: взвешенный выбор внутри пула

Свойства:
├── Детерминированность: все узлы вычисляют одного победителя
├── Непредсказуемость: seed неизвестен до закрытия prev τ₂
└── Защита от grinding: seed определяется prev_slice_hash
```

### P2P-аттестация

```
1. Узел подписывает координату (привязка к prev_slice_hash)
2. Рассылает подпись через gossip
3. Peers проверяют и накапливают в пуле
4. При закрытии τ₂ → presence_root из пула
5. Опоздавшие подписи переносятся на следующий τ₂
```

Полная спецификация: [layer_1.md](layer_1.md)

---

## Протокол ACP

### Базовая концепция

Координаты — статичная структура.

Все позиции существуют в четырёхмерной структуре. Наблюдение этих позиций — последовательно. Присутствие — верифицированное занятие координат.

### Принципы

**Принцип 1. Координатная семантика**

Таймчейн — индексированное множество темпоральных координат. Индекс обеспечивает адресацию. Инкремент счётчика отражает изменение показаний измерительного аппарата.

**Принцип 2. Инвариантность к скорости наблюдения**

Система инвариантна к скорости и направлению наблюдения координат. Накопленное присутствие зависит от того, какие координаты были заняты. Вес определяется занятыми позициями.

**Принцип 3. Направленность как свойство наблюдателя**

Направленность — свойство наблюдателя. Каждая операция подписания увеличивает энтропию наблюдателя. Стрела времени возникает из акта наблюдения.

**Принцип 4. Положительная сумма**

Распределение имеет положительную сумму. Каждый цикл τ₂ создаёт 3000 Ɉ. Узел, проигравший лотерею, сохраняет накопленный вес. Вероятность в последующих раундах сохраняется. Все честные участники получают положительное математическое ожидание за достаточный период.

**Принцип 5. Таймслайсы как вложенные позиции**

Таймслайс — дискретная позиция в координатной структуре. Позиции существуют. Узел занимает позицию или свободен от неё (бинарно). Таймслайсы образуют иерархию вложенности: τ₂ содержит 10 позиций τ₁, τ₃ содержит 2016 позиций τ₂, τ₄ содержит 104 позиции τ₃. Каждый уровень агрегирует присутствие нижнего уровня. Накопление — сумма занятых позиций на всех уровнях.

### Таймслайсы

**Таймслайс** — дискретная позиция в координатной структуре.

| Таймслайс | Длительность | Минуты | Назначение |
|-----------|--------------|--------|------------|
| τ₁ | 1 минута | 1 | Финализация транзакций |
| τ₂ | 10 минут | 10 | Распределение Ɉ из банка времени |
| τ₃ | 14 дней | 20,160 | Адаптивный кулдаун |
| τ₄ | 4 года | 2,102,400 | Эпоха (халвинг) |

**Роль каждого таймслайса:**

```
τ₁ (1 минута):
├── Единица присутствия — минимальный квант подписи
├── Финализация транзакций — транзакции включаются в текущий τ₁
├── Накопление подписей — каждый τ₁ = 1 подпись = 1 вес
└── Бинарность: присутствие = {0, 1}

τ₂ (10 минут):
├── Распределение наград — 3000 Ɉ из банка времени
├── Формирование слайса — 10 τ₁ подписей → presence_root
├── Лотерея победителя — seed = SHA3-256(prev_hash ‖ τ₂_index)
└── Публикация блока — победитель подписывает и публикует

τ₃ (14 дней):
├── Скользящее окно адаптивного кулдауна
├── Медиана регистраций в окне τ₃ определяет кулдаун
└── Тир 3 вес — 3 × 20,160 = 60,480 веса

τ₄ (4 года):
├── Эпоха — полный цикл сети
├── Халвинг — награда уменьшается вдвое
└── Тир 4 вес — 4 × 2,102,400 = 8,409,600 веса
```

Свойства:
- Таймслайсы — позиции, которые существуют
- Узел занимает таймслайс (бинарно: 0 или 1)
- Каждая координата обрабатывается последовательно

**Бинарность τ₁:**
```
Присутствие в τ₁ = {0, 1}

1000 подписей за 1 минуту = 1 присутствие
1 подпись за 1 минуту     = 1 присутствие

Вес = количество занятых τ₁.
```

### Таймчейн

**Таймчейн** — цепь слайсов τ₂, связанных криптографически.

```
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ Slice 0 │───▶│ Slice 1 │───▶│ Slice 2 │───▶│ Slice N │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
     │              │              │              │
  prev_hash     prev_hash     prev_hash     prev_hash
     =              =              =              =
  genesis     H(Slice 0)   H(Slice 1)   H(Slice N-1)
```

**Структура слайса:**
```
Slice N:
├── header:
│   ├── prev_hash: SHA3-256(Slice N-1)
│   ├── timestamp: UTC (Layer 1 peers + Layer 2 NTS)
│   ├── slice_index: N
│   └── winner_pubkey: ML-DSA-65 pubkey
├── presence_root: Merkle(подписи присутствия за τ₂)
├── tx_root: Merkle(транзакции)
└── signature: ML-DSA-65(winner_privkey, header)
```

**Свойства:**
- Каждый слайс ссылается на предыдущий через prev_hash
- Порядок определяется хеш-цепью
- Layer 2 (NTS) калибрует timestamp относительно UTC

### Внешняя валидация координат

Layer 2 (NTS) наблюдает координатную позицию и аттестует её.

```
NTS-сервер → "Позиция: T = 1735989600 UTC"
           → Криптографически аутентифицирован (TLS 1.3 + AEAD)
           → Опциональная валидация для Layer 1
```

Роль:
- Внешний якорь с UTC
- 52 NTS сервера (14 стран)
- Опциональная проверка peer consensus

---

## Типы узлов

| Тип | Описание | Подпись | Шанс Stage 1 |
|-----|----------|---------|--------------|
| **Full Node** | Полная история + валидация | каждую 1 мин | 70% |
| **Light Node** | История с момента подключения | каждую 1 мин | 20% |
| **Light Client** | Telegram/Discord/приложение | каждые 10 мин | 10% |

```
Безопасность сети: Full Node (70%)
Масштабирование:   Light Node (20%) + Light Client (10%)
```

### Хранение ключей Light Client

```
Light Client (мобильное приложение / бот):
├── Мнемоника 24 слова хранится локально
├── Приватный ключ генерируется из мнемоники
├── Подпись создаётся на устройстве пользователя
├── Telegram/Discord — только transport для отправки
└── Self-sovereign: ключи остаются на устройстве

Self-sovereign ключи:
├── Seed phrase хранится локально
├── Транзакции подписываются локально
└── Сеть получает только подписанные транзакции
```

Telegram/Discord бот транслирует подпись в P2P-сеть. Ключи остаются на устройстве пользователя.

---

## Координатные тиры

### Структура

| Тир | Длительность | Минуты | Вес/слайс | Формула |
|-----|--------------|--------|-----------|---------|
| 1 | 1 минута | 1 | 1 | 1 × 1 |
| 2 | 10 минут | 10 | 20 | 2 × 10 |
| 3 | 14 дней | 20,160 | 60,480 | 3 × 20,160 |
| 4 | 4 года | 2,102,400 | 8,409,600 | 4 × 2,102,400 |

Формула веса:
```
вес_за_слайс = номер_тира × минуты_тира
общий_вес = количество_слайсов × вес_за_слайс
```

### Прогрессия

**Full Node / Light Node:**
```
1 мин (тир 1) → 10 мин (тир 2) → 14 дней (тир 3) → 4 года (тир 4)
```

**Light Client:**
```
10 мин (тир 2) → 14 дней (тир 3) → 4 года (тир 4)
```

### Требование 90% присутствия

```
9/10 минут подписано     → +1 слайс тира 2
90% тира 2 за 14 дней    → +1 слайс тира 3
90% тира 3 за 4 года     → +1 слайс тира 4
```

### Сброс счётчиков

```
Получен слайс тира N → сброс счётчика тира N-1
Вес сохраняется и растёт бессрочно
```

Слайсы всех тиров накапливаются бессрочно.

---

## Лотерея

### Двухуровневая структура

Каждые 10 минут распределяется 3000 Ɉ:

```
Stage 1: Лотерея по типу узла
├── 70% → Full Node pool
├── 20% → Light Node pool
└── 10% → Light Client pool

Stage 2: Лотерея по весу внутри пула
├── P(узел_i) = вес_i / Σ весов_в_пуле
└── Победитель получает 3000 Ɉ + все комиссии
```

### Требование для участия

```
Адаптивный кулдаун определяет право на участие в лотерее.
Кулдаун: 1 τ₂ (10 мин) — 25,920 τ₂ (180 дней) на основе медианы регистраций.
```

### Пример

```
Full Node Pool (выиграл Stage 1):
├── Node A: 1 слайс тира 3 = 60,480 веса → 99.6%
├── Node B: 10 слайсов тира 2 = 200 веса → 0.33%
└── Node C: 50 слайсов тира 1 = 50 веса → 0.08%
```

### Детерминированный выбор

Лотерея детерминистична — все узлы вычисляют одного победителя.

```
seed = SHA3-256(prev_slice_hash ‖ τ₂_index)

prev_slice_hash — хеш предыдущего закрытого слайса (уже фиксирован)
τ₂_index — порядковый номер текущего слайса (детерминирован)
```

**Порядок операций:**
```
1. τ₂ закрывается (10 минут прошло по цепи)
2. seed вычисляется (prev_slice_hash уже известен)
3. Все узлы вычисляют одного победителя
4. Победитель формирует presence_root из P2P-подписей
5. Победитель публикует слайс
```

**Выбор победителя:**
```
Stage 1: seed mod 100
├── 0-69  → Full Node pool
├── 70-89 → Light Node pool
└── 90-99 → Light Client pool

Stage 2: взвешенный выбор внутри пула
├── Сортировка узлов по pubkey (детерминированный порядок)
├── Кумулятивные веса: [w₁, w₁+w₂, ..., Σwᵢ]
├── target = seed mod Σwᵢ
└── Победитель = первый узел где cumulative > target
```

**Защита от grinding:**
- seed зависит от prev_slice_hash (фиксирован)
- seed вычисляется ДО того как победитель формирует слайс
- Победитель получает уже определённый seed

Все узлы имеют одинаковые данные → одинаковый результат → единый победитель.

### Роль победителя

```
Победитель лотереи:
├── Собирает транзакции из mempool
├── Формирует таймслайс:
│   ├── presence_root: Merkle подписей присутствия
│   ├── tx_root: Merkle транзакций
│   ├── prev_hash: хеш предыдущего τ₂
│   └── timestamp: UTC
├── Подписывает таймслайс (ML-DSA-65)
├── Публикует в сеть
└── Получает 3000 Ɉ + комиссии
```

### Fork-choice rule

При network partition возможны временные форки. Сеть сходится по правилу:

```
Каноническая цепь = самая длинная цепь + наибольший суммарный вес участников

1. Длина цепи (количество τ₂ слайсов)
2. При равной длине → суммарный вес presence в цепи
3. При равном весе → меньший хеш head слайса
```

**Схождение после partition:**

```
Partition:
├── Сегмент A: цепь A₁ → A₂ → A₃
└── Сегмент B: цепь B₁ → B₂

Восстановление связи:
├── Сравнение: len(A) = 3, len(B) = 2
├── A длиннее → A каноническая
├── Узлы B переключаются на A
└── Подписи из B₁, B₂ остаются в orphan-ветке
```

**Почему форки редки:**

- Детерминированная лотерея: при одинаковом view → один победитель
- P2P gossip: подписи распространяются быстро
- 10-минутное окно: достаточно для глобального распространения
- Форки только при реальном network partition

---

## Sybil-модель

### Два типа "атак"

```
Атака на СЕТЬ:                    Атака на УЧАСТНИКОВ:
├── Подделка транзакций           ├── Доля в распределении наград
├── Изменение истории             ├── Конкуренция за лотерею
├── Нарушение консенсуса          └── Вытеснение других участников
└── Цензура транзакций

Sybil в Montana = конкуренция за награды
```

### Sybil влияет только на распределение наград

```
1000 ключей дают:
├── 1000× шанс в лотерее (линейно)
├── 1000× затраты на инфраструктуру
└── Линейное масштабирование (1:1)

Безопасность сети:
├── Транзакции защищены криптографией (ML-DSA)
├── История защищена хеш-цепью (SHA3-256)
├── Консенсус защищён детерминированной лотереей
└── Накопление присутствия = реальное время
```

### Линейное масштабирование

Множество идентичностей даёт линейное преимущество.

```
1 ключ × 14 дней    = 60,480 веса
1000 ключей × 14 дней = 60,480,000 веса

Затраты: 1000× ресурсов (узлы, bandwidth, хранение)
Выгода:  1000× веса
Отношение: линейное (1:1)
```

### Линейное масштабирование

```
Montana:
├── 1000 ключей = 1000× вес = 1000× шанс в лотерее
├── 1000× затраты (узлы, bandwidth, хранение)
└── Конкуренция за награды = участие
```

### Sybil поддерживает сеть

```
Sybil Full Node (1000 узлов):
├── Хранит полную историю × 1000
├── Валидирует транзакции × 1000
├── Распространяет подписи × 1000
├── Поддерживает инфраструктуру × 1000
└── Расширяет сеть

Sybil Light Node:
├── Хранит историю с момента подключения
├── Участвует в P2P-аттестации
└── Поддерживает распространение

Sybil Light Client:
├── 10% шанс на тип узла
├── Конкурирует по весу с другими клиентами
└── Минимальный вклад в инфраструктуру
```

### Честные узлы выигрывают в долгосроке

```
Новый атакующий (день 0):    0 веса, кулдаун до лотереи
Честный узел (1 год):        1,572,480 веса, 26× преимущество на ключ

Долгосрочный Sybil:
├── Поддерживает сеть годами
├── Накапливает вес как все
├── Создаёт равную конкуренцию
└── Безопасность сохраняется (криптографическая)
```

### Почему это работает

| Свойство | Следствие |
|----------|-----------|
| Линейные затраты | Затраты пропорциональны масштабу |
| Линейная выгода | Выгода пропорциональна затратам |
| Симметричный ответ | Другие участники могут масштабироваться |
| Время одинаково | Накопление присутствия = реальное время |
| Безопасность отделена | Валидация криптографическая |
| Инфраструктура | Sybil расширяет и поддерживает сеть |

### Преимущество времени

```
Новый атакующий с 1000 Full Nodes:
├── День 0: кулдаун (адаптивный, 1 τ₂ — 180 дней)
├── После кулдауна: участие в лотерее
└── Вес: минимальный (только начал накапливать)

Существующие участники (1 год):
├── ~26 слайсов tier 3 каждый
├── Каждый ключ: 1,572,480 веса
└── Преимущество: ~26× на ключ
```

Время — единственный ресурс, распределённый равномерно.

---

## Адаптивный кулдаун

### Определение

Адаптивный кулдаун определяется сглаженной медианой регистраций с защитой от манипуляций.

```
Кулдаун = f(сглаженная медиана, rate limit)

Минимум:     1 день (144 τ₂) — вход требует минимум 1 день
Максимум:    180 дней (25,920 τ₂)
Окно:        скользящее τ₃ (14 дней)
Сглаживание: 4 τ₃ (56 дней) скользящее среднее
Rate limit:  ±20% максимальное изменение за τ₃
```

Кулдаун фиксируется в момент регистрации узла. Каждый тип узла (Full/Light/Client) имеет независимую медиану.

### Защита от манипуляций

```
Три механизма защиты:

1. Сглаживание (4 τ₃ = 56 дней):
   ├── Скользящее среднее медиан за 4 τ₃
   ├── Резкий всплеск регистраций размазывается по 56 дням
   └── Манипуляция требует долгосрочных затрат

2. Rate limiting (±20% за τ₃):
   ├── Кулдаун изменяется максимум на 20% за τ₃
   ├── Резкие скачки имеют ограниченный эффект
   └── Сеть адаптируется плавно

3. Минимальный порог (1 день):
   ├── Вход требует минимум 1 день даже при пустой сети
   ├── Атакующий тратит минимум 1 день на каждый узел
   └── Sybil-атака растягивается во времени
```

### Механика

**Регистрация нового узла:**
```
RegisterNode(pubkey, node_type):
    current_τ₂ = current_slice_index()
    smoothed_median = get_smoothed_median(node_type)  // 4 τ₃ average
    raw_cooldown = calculate_cooldown(smoothed_median, current_registrations)
    rate_limited = apply_rate_limit(raw_cooldown, previous_cooldown)  // ±20%
    cooldown = clamp(rate_limited, MIN, MAX)
    cooldown_until = current_τ₂ + cooldown

    node.cooldown_until = cooldown_until  # Фиксируется
    node.status = COOLDOWN

    record_registration(current_τ₂, node_type)
    update_median(node_type)
```

**Формула кулдауна:**
```
ratio = current_registrations / smoothed_median

Если ratio ≤ 1.0:
    raw_cooldown = MIN + ratio × (MID - MIN)

Если ratio > 1.0:
    raw_cooldown = MID + (ratio - 1) × (MAX - MID)

Rate limit:
    max_change = previous × 20%
    cooldown = clamp(raw_cooldown, previous - max_change, previous + max_change)

MIN = 144 τ₂ (1 день)
MID = 1008 τ₂ (7 дней)
MAX = 25,920 τ₂ (180 дней)
```

Линейная калибровка с защитой: ниже медианы — быстрый вход, выше медианы — замедление. Сглаживание и rate limit защищают от манипуляций.

### Состояние узла в кулдауне

```
Узел в кулдауне:
├── Подписывает (доказывает присутствие)
├── Включён в presence_root (с флагом cooldown_until)
├── Вес накапливается после окончания кулдауна
├── ChainWeight учитывает только active узлы
└── Лотерея доступна после окончания кулдауна

После кулдауна:
├── Переходит в статус ACTIVE
├── Начинает накапливать вес
└── Сразу участвует в лотерее
```

### Переходы между тирами

```
Апгрейд тира (Light Client → Light Node → Full Node):
├── Новый кулдаун для нового тира
├── Вес сохраняется
└── Медиана берётся из нового тира
```

### Реактивация

```
Узел офлайн > τ₃ (14 дней):
├── При возврате: новый кулдаун (как для нового узла)
├── Вес сохранён
└── Защита от exit-reenter
```

### Genesis

```
День 1 сети:
├── Медиана = M_default (начальное значение)
├── M_default = 1 τ₂
├── Genesis nodes: мгновенный вход
└── Первые узлы входят быстро

Далее медиана органически настраивается по мере роста сети.
```

### Публикация в слайсе

```
SliceHeader содержит:
├── cooldown_medians: [Full, Light, Client]  # Для верификации
├── registrations: [Full, Light, Client]      # Новые за этот τ₂
```

Любой узел может независимо проверить корректность кулдауна.

### Sybil с адаптивным кулдауном

**Низкая активность (ниже медианы):**
```
Атакующий регистрирует узел
├── current / smoothed_median < 1
├── Кулдаун = 1-7 дней (минимум 1 день)
└── Вход возможен, минимум 1 день ожидания
```

**Массовая атака (выше медианы):**
```
Атакующий регистрирует 1000 узлов
├── current / smoothed_median >> 1
├── Сглаживание размазывает эффект по 56 дням
├── Rate limit ограничивает рост 20% за τ₃
├── Кулдаун растёт до 180 дней постепенно
└── Атака растягивается во времени

Три уровня защиты:
├── 1-день минимум: вход требует минимум 1 день
├── Сглаживание: манипуляция требует долгосрочных затрат
└── Rate limit: резкие скачки имеют ограниченный эффект
```

### Защита от inflation ChainWeight

```
Узел в кулдауне:
├── Подписи включены в presence_root
├── ChainWeight учитывает только active узлы
├── Вес накапливается после окончания кулдауна
└── Кулдаун изолирует от влияния на вес цепи

ChainWeight = Σ подписей со статусом ACTIVE
```

### Тройная защита

```
1. Минимальный порог:   1 день — вход требует минимум 1 день
2. Сглаживание:         4 τ₃ (56 дней) — манипуляция размазывается
3. Rate limit:          ±20% за τ₃ — резкие скачки ограничены
4. Накопление веса:     Долгосрочные участники имеют больший вес
```

### Параметры

| Параметр | Значение | Обоснование |
|----------|----------|-------------|
| MIN | 144 τ₂ (1 день) | Минимальный кулдаун — базовый порог для всех узлов |
| MAX | 25,920 τ₂ (180 дней) | Максимальная защита |
| MID | 1008 τ₂ (7 дней) | Точка перегиба при медиане |
| Окно медианы | τ₃ (14 дней) | Достаточная статистика |
| Сглаживание | 4 τ₃ (56 дней) | Размазывание манипуляций |
| Rate limit | ±20% за τ₃ | Ограничение резких скачков |
| Per tier | Да | Независимые медианы |

Полная спецификация: [layer_0.md](layer_0.md) L-0.14

---

## Детерминированный presence_root

### Определение

presence_root вычисляется детерминистично из всех валидных подписей:

```
presence_root(τ₂) = Merkle(
    canonical_order(
        {sig : sig.valid ∧ sig.timestamp ∈ τ₂ ∧ sig.prev_hash = correct}
    )
)

canonical_order = sort_by(sig.timestamp, SHA3-256(sig))
```

Победитель лотереи публикует детерминированный результат.

### Каноническое упорядочение

```
Порядок подписей:
1. Сначала по timestamp (восходящий)
2. При равных timestamp — по хешу подписи (лексикографически)

Результат: детерминированный порядок для любого набора подписей
```

### Механика

```
Период τ₂ (10 минут):

1. Узлы подписывают координаты
2. Подписи распространяются через P2P gossip
3. Каждый узел накапливает валидные подписи в локальном пуле
4. При закрытии τ₂:
   ├── Все узлы имеют одинаковый набор подписей
   ├── Все вычисляют одинаковый presence_root
   └── Победитель публикует результат

Подписи включаются по детерминированному правилу.
```

### Grace period

```
grace_period = 30 секунд после закрытия τ₂

Подпись включается если:
├── sig.timestamp ∈ τ₂
├── sig.prev_hash = correct
├── sig получена до (τ₂.end + grace_period)
└── sig.valid = true

После grace_period → presence_root фиксируется
```

### Fork-choice по весу подписей

```
ChainWeight(chain) = Σ len(slice.presence_sigs) для всех слайсов

Разрешение форков:
1. ChainWeight (больше подписей = лучше)
2. При равном весе → длина цепи
3. При равной длине → меньший хеш head

Цензура подписей → меньше подписей → легче цепь → проиграет
```

### Власть победителя

```
Победитель лотереи:
├── Собирает транзакции из mempool
├── Формирует presence_root → ДЕТЕРМИНИРОВАННО
├── Подписывает слайс (ML-DSA-65)
└── Публикует

Победитель решает:
├── Включение/исключение транзакций

Подписи присутствия:
└── Определяются детерминированно canonical_order
```

### Sybil как участие

```
1000 Sybil-узлов:
├── 1000 подписей в presence_root
├── +1000 к ChainWeight
├── Усиление сети = участие

Sybil = участие.
Больше подписей = тяжелее цепь.
```

### Свойства

| Свойство | Механизм |
|----------|----------|
| Детерминированность | canonical_order + Merkle |
| Цензуроустойчивость | Fork-choice по весу |
| Универсальность | Работает при любом соотношении |
| Время = вес | Присутствие определяет ChainWeight |

Полная спецификация: [layer_0.md](layer_0.md) L-0.15

---

## Циклы

### 10-минутный цикл

```
Каждые 10 минут:
├── Проверка: 9+ минут подписано?
├── Да → +1 слайс тира 2
├── Распределение 3000 Ɉ
└── Сброс счётчика минутных слайсов
```

### Цикл τ₃ (14 дней)

```
Каждые τ₃:
├── Проверка: 90%+ слайсов тира 2?
├── Да → +1 слайс тира 3
└── Сброс счётчика слайсов тира 2
```

### 4-летний цикл

```
Каждые 4 года:
├── Проверка: 90%+ слайсов тира 3?
├── Да → +1 слайс тира 4
└── Сброс счётчика слайсов тира 3
```

---

## Токеномика

### Эмиссия

```
Каждый τ₂:     3000 Ɉ (каждые 10 минут)
В час:         18,000 Ɉ
В день:        432,000 Ɉ
В год:         157,680,000 Ɉ

Общий запас:   1,260,000,000 Ɉ
Халвинг:       каждые 210,000 τ₂ (~4 года)
```

### Распределение

```
Пре-аллокация: 0
Фаундеры:      0
Резерв:        0

Всё через лотерею присутствия.
```

---

## Синхронизация времени

Montana использует двухслойную архитектуру синхронизации времени.

### Архитектура

```
┌─────────────────────────────────────────────────────────┐
│  Layer 1: Peer Time Consensus (обязательный)           │
│  ├── TimeOffsets от peers (до 50 samples)              │
│  ├── Медиана offsets                                   │
│  ├── WARN_THRESHOLD = 10 минут                         │
│  └── MTP + future limit для слайсов                    │
└─────────────────────────────────────────────────────────┘
                              ↑
                    Внешняя валидация (опционально)
                              ↓
┌─────────────────────────────────────────────────────────┐
│  Layer 2: NTS Validation (опциональный)                │
│  ├── 3-5 случайных NTS серверов                        │
│  ├── TLS 1.3 + AEAD аутентификация                     │
│  ├── Медиана ответов                                   │
│  └── Проверка: |peer_median - nts_median| < порог      │
└─────────────────────────────────────────────────────────┘
```

### Layer 1: Peer Time Consensus

Основной механизм защиты времени. Работает автономно.

```
TimeOffsets:
├── Каждый peer сообщает своё время при handshake
├── offset = peer_time - local_time
├── Хранится до 50 последних samples
├── Медиана offsets = network time deviation
└── Предупреждение если |median| > 10 минут

Валидация слайсов:
├── MTP (Median Time Past): timestamp > median(11 последних слайсов)
├── Future limit: timestamp < now + 2 часа
└── Порядок определяется хеш-цепью

Свойства:
├── Полностью децентрализован
├── Автономен (работает при partition)
└── Достаточен для защиты от атак на время
```

### MTP (Median Time Past)

```
Каждый слайс:
├── Берёт timestamps 11 последних слайсов
├── Вычисляет медиану
├── Новый timestamp > MTP

MTP защищает от:
├── Отката времени назад
├── Манипуляции единичным слайсом
└── 51% атаки на время (требует контроль 6+ слайсов)
```

### Future Limit

```
MAX_FUTURE_TIME = 2 часа

Слайс принимается если:
├── timestamp ≤ local_time + MAX_FUTURE_TIME
└── Узел отклоняет слайсы из далёкого будущего

Защита от:
├── Преждевременной публикации слайсов
└── Time-warp вперёд
```

### Layer 2: NTS Validation

Внешний якорь с реальностью. Опционален.

```
Протокол: RFC 8915 (Network Time Security)
├── NTS-KE: TLS 1.3, порт 4460
│   ├── ALPN: ntske/1
│   ├── Key export: RFC 5705
│   └── Cookies для аутентификации
├── NTS NTP: UDP порт 123
│   ├── AEAD_AES_SIV_CMAC_256
│   └── Криптографически аутентифицированные timestamps

Запрос:
├── 3-5 случайных NTS серверов из пула
├── Медиана ответов = nts_time
├── Сравнение: |peer_median - nts_time|
└── Предупреждение если расхождение > 10 минут
```

### NTS серверы

```
Глобальный пул: 52 сервера, 14 стран

├── Global: Cloudflare (time.cloudflare.com)
├── Europe: Netnod (Sweden), PTB (Germany), SIDN (Netherlands)
├── Americas: System76, NIC.br (Brazil), MBIX (Canada)
└── Asia: Singapore

Stratum: 1-2
Аутентификация: TLS 1.3 + AEAD
```

### Режимы работы

```
Normal:
├── Layer 1 активен (peer offsets)
├── Layer 2 активен (NTS validation)
├── Валидация: MTP + future limit
└── Предупреждения при расхождении

Offline NTS:
├── Layer 1 активен
├── Layer 2 недоступен
├── Цепь продолжает работать
└── Достаточно для полной функциональности

Расхождение > 10 минут:
├── Предупреждение в логах
├── Рекомендация проверить системные часы
└── Узел продолжает работать
```

### Защита от атак на время

| Атака | Защита |
|-------|--------|
| 50%+ peers врут | Layer 2 (NTS) детектирует расхождение |
| NTS compromise | Layer 1 (peer consensus) основной |
| Time-warp назад | MTP (11 слайсов) |
| Time-warp вперёд | Future limit (2 часа) |
| Eclipse + time attack | NTS детектирует изоляцию |

### Параметры

| Параметр | Значение |
|----------|----------|
| TimeOffsets capacity | 50 samples |
| WARN_THRESHOLD | 10 минут |
| MTP window | 11 слайсов |
| MAX_FUTURE_TIME | 2 часа |
| NTS query count | 3-5 серверов |
| NTS timeout | 10 секунд |

---

## Genesis

### Genesis block

```
Genesis block (Slice 0):
├── Hardcoded в коде
├── timestamp: T₀ (фиксированная координата)
├── prev_hash: 0x00...00 (32 байта нулей)
├── presence_root: Merkle(genesis_signatures)
├── tx_root: 0x00...00 (пустой)
└── signature: ML-DSA-65(genesis_key)
```

### Seed nodes

```
DNS seeds:
├── seed.montana.network
├── dnsseed.montana.network
└── Несколько независимых операторов

Hardcoded fallback:
├── Список IP-адресов в коде
└── Используется если DNS недоступен
```

### Bootstrap sequence

```
1. Новый узел читает genesis block (hardcoded)
2. Подключается к seed nodes (20 hardcoded + 80 P2P)
3. Собирает chain info + timestamps от 100 peers (25+ подсетей)
4. Верификация времени (защита от malware):
   ├── Медиана timestamp от 100 peers
   ├── Сравнение с локальными часами
   ├── <1 минута: норма (сетевые задержки)
   ├── 1-10 минут: предупреждение
   └── >10 минут: CRITICAL, bootstrap остановлен
5. Верификация hardcoded nodes (1% толерантность)
6. Скачивает таймчейн от genesis до head
7. Верифицирует каждый слайс:
   ├── prev_hash корректен
   ├── presence_root валиден
   ├── cumulative_weight корректен
   ├── subnet_reputation_root корректен
   └── signature валидна
8. Выбор peers по приоритету возраста (старые peers первыми)
9. Начинает подписывать координаты
```

### Верификация времени при bootstrap

```
Защита от манипуляции часов:
├── Malware может изменить системное время
├── 100 peers из 25+ подсетей сообщают свой timestamp
├── Медиана 100 peers = сетевое время
├── Атакующий контролирует <51 peer из 25+ подсетей

Пороги расхождения:
├── <1 минута:   норма (сетевые задержки)
├── 1-10 минут:  предупреждение в логах
└── >10 минут:   CRITICAL, bootstrap остановлен

Все расчёты высоты используют сетевое время (медиану peers).
```

### Аутентификация hardcoded узлов

```
Challenge-Response протокол:

1. Client → Hardcoded:  AuthChallenge(random_32_bytes)
2. Hardcoded → Client:  AuthResponse(Version, ML-DSA-65_signature)
3. Client проверяет подпись против ожидаемого публичного ключа

Хранение идентичности:
├── IP-адрес привязан к ML-DSA-65 публичному ключу
├── Публичные ключи вкомпилированы в бинарник
└── Приватные ключи хранятся операторами (HSM рекомендовано)
```

**Защита от BGP/MITM:**

| Атака | Результат |
|-------|-----------|
| BGP hijack | Атакующий требует приватный ключ → AuthResponse невалиден |
| DNS poisoning | Клиент проверяет подпись, независимо от DNS |
| Man-in-the-middle | Noise шифрование + AuthResponse = двойная защита |

### Параметры genesis

| Параметр | Значение |
|----------|----------|
| Genesis timestamp | T₀ (определяется при запуске) |
| Genesis prev_hash | 0x00...00 |
| Seed nodes | ≥3 DNS seeds |
| Fallback IPs | ≥10 hardcoded |
| Bootstrap peers | 100 (20 hardcoded + 80 P2P) |
| Subnet diversity | 25+ уникальных /16 |
| Time tolerance | <1 мин норма, >10 мин CRITICAL |

Полная спецификация: [layer_0.md](layer_0.md) L-0.16

---

## Eclipse protection

### Эффект в Montana

```
Eclipsed Full Node:
├── Подписывает координаты (локально)
├── Подписи достигают только изолированного сегмента
├── Включаются только в локальный presence_root
├── Вес сохраняется
├── Накопление приостановлено до восстановления
└── При восстановлении: продолжает нормально

Eclipse = потеря liveness для узла
Безопасность сети сохраняется
```

### Механизмы защиты

```
Full bootstrap при КАЖДОМ рестарте (startup.rs):
├── 100 peers (20 hardcoded + 80 P2P via gossip)
├── 25+ unique /16 subnets required
├── Hardcoded nodes must match median ±1%
├── Peer selection prioritized by presence age
└── Attack cost: 51+ peers from 25+ /16 subnets AND 15+ hardcoded

Разнообразие соединений:
├── MIN_OUTBOUND_PEERS = 8
├── MAX_CONNECTIONS_PER_IP = 2
├── MAX_PEERS_PER_NETGROUP = 2 (на /16 подсеть)
└── Периодическая ротация peers

Многослойный eviction (28+ защищённых слотов):
├── Слой 1: NoBan разрешение (все)
├── Слой 2: Разнообразие netgroup (4)
├── Слой 3: Минимальная задержка (8)
├── Слой 4: Недавняя трансляция транзакций (4)
├── Слой 5: Недавняя трансляция слайсов (4)
└── Слой 6: Долгосрочное соединение (8)

AddrMan с бакетами:
├── New таблица: 1024 бакета × 64 слота = 65,536 адресов
├── Tried таблица: 256 бакетов × 64 слота = 16,384 адреса
├── Криптографическое распределение (SipHash с random key)
└── Распределение по бакетам непредсказуемо для атакующего

Feeler-соединения:
├── Каждые 2 минуты: выбор адреса из New таблицы
├── Попытка TCP-соединения (5 секунд таймаут)
├── Успех → перемещение в Tried таблицу
└── Валидация доступности адреса

Кеш ответов адресов:
├── 5 минут TTL на peer
├── Защита от timing fingerprinting
└── Приватность

Rate limiting (token bucket):
├── Addr: 1000 burst, 0.1/сек sustained
├── Inv: 5000 burst, 10/сек sustained
├── GetData: 1000 burst, 5/сек sustained
└── Защита от flooding

Flow control:
├── Receive queue: 5 МБ лимит
├── Send queue: 1 МБ лимит
└── Пауза при достижении лимита, возобновление после обработки

Discouraged filter (rolling bloom):
├── 50,000 адресов ёмкость
├── 0.000001 false positive rate
├── Мягкое наказание (деприоритизация)
└── Авто-истечение через rolling

NTS reality check:
├── Независимый источник времени (Слой 2)
├── Расхождение NTS vs peers = признак Eclipse
└── Warning + reconnect к seeds
```

### Детекция

```
Признаки Eclipse:
├── Таймчейн стагнирует
├── presence_root содержит только локальные подписи
├── NTS расходится с peers
└── Все peers из одной /16 или AS

Реакция:
├── Warning в логах
├── Reconnect к seed nodes
└── Pause signing до восстановления
```

Полная спецификация: [NETWORK_SPECIFICATION.md](NETWORK_SPECIFICATION.md)

---

## Детерминированный tx_root

### Определение

tx_root вычисляется детерминистично из всех валидных транзакций текущего τ₂:

```
tx_root(n) = Merkle(
    sort_by(SHA3-256(tx)),
    {tx : tx.valid ∧ tx.timestamp ∈ τ₂(n) ∧ tx.nonce_valid}
)
```

Победитель лотереи публикует детерминированный результат.

### tx.timestamp

```
tx.timestamp:
├── Устанавливает: отправитель
├── Цель: определить в какой τ₂ попадает tx
└── Упорядочение определяется hash

Валидация узлами:
├── tx.timestamp ≤ node_time + 30 сек (в пределах grace period)
├── tx.timestamp ≥ current_τ₂.start (в текущем τ₂)

Порядок в tx_root:
├── sort_by(SHA3-256(tx)) — только хеш
├── Хеш непредсказуем до подписания tx
└── Отправитель контролирует τ₂, позиция определяется hash
```

### Grace period

```
grace_period = 30 секунд после закрытия τ₂

Транзакция включается если:
├── tx.timestamp ∈ τ₂(n)
├── tx получена до (τ₂(n).end + grace_period)
├── tx.valid = true
└── tx.nonce_valid = true

После grace_period → tx_root фиксируется
```

### Пропагация

```
Реальность сети:
├── Обычно: <1 секунда глобально
├── Редко: <1 минута (перегрузка, плохая связь)
├── Grace period 30 сек: покрывает 99%+ случаев

Если mempools различаются:
├── Разные tx_root → форк
├── ChainWeight решает (по presence_sigs)
├── "Проигравшие" tx: повторная отправка
└── Частота: редко
```

### Свойства

| Свойство | Гарантия |
|----------|----------|
| Детерминированность | Все узлы вычисляют одинаковый tx_root |
| Латентность | 0-30 секунд (grace period) |
| Цензуроустойчивость | Детерминированное включение |
| MEV-устойчивость | Порядок по hash, детерминирован |
| Fork tolerance | ChainWeight решает споры |

Полная спецификация: [layer_0.md](layer_0.md) L-0.18

---

## Параметры протокола

### Пороги присутствия

| Тир | Порог | Обоснование |
|-----|-------|-------------|
| 1 → 2 | 9/10 минут (90%) | Допуск на кратковременные сбои |
| 2 → 3 | 90% τ₂ за 14 дней | Консистентность |
| 3 → 4 | 90% τ₃ за 4 года | Долгосрочное присутствие |

### Пограничные случаи

**Узел офлайн весь τ₃:**
```
Слайсы τ₂ за этот период = 0
Слайс τ₃ требует присутствия
Вес сохраняется (рост приостановлен)
```

**Потеря и восстановление:**
```
Вес = сумма всех полученных слайсов × их веса
Вес сохраняется бессрочно
Восстановление = продолжение накопления
```

---

## Векторы атак

### Long-range атака

**Описание:** Атакующий представляет альтернативную историю подписей.

**Защита:**
- Хеш-цепь таймслайсов криптографически связана
- presence_root каждого τ₂ фиксирует полученные подписи
- Альтернативная история требует пересоздания всей цепи
- Узлы хранят локальные чекпоинты (история фиксирована)

### Eclipse атака

**Описание:** Изоляция узла от честной сети.

**Защита (startup.rs):**
- Full bootstrap при КАЖДОМ рестарте (100 peers, 25+ /16 subnets)
- Hardcoded nodes must match network median ±1%
- Attack cost: 51+ peers from 25+ /16 subnets AND 15+ hardcoded
- Runtime: netgroup diversity, eviction protection (28 slots)
- Layer 2 (NTS) детектирует изоляцию (расхождение с peers)

### Time-warp атака

**Описание:** Манипуляция локальными часами узла.

**Защита:**
- MTP: timestamp > median(11 последних слайсов)
- Future limit: timestamp < now + 2 часа
- prev_slice_hash привязывает подпись к текущему τ₂
- Layer 2 (NTS) обеспечивает отображение в UTC

---

## Криптографические редукции

Безопасность Montana сводится к стандартным криптографическим предположениям.

### Базовые редукции

| Атака | Цель | Редукция к |
|-------|------|------------|
| Подделка подписи присутствия | Создать Sig(T), имея только pubkey | ML-LWE (стойкость ML-DSA-65) |
| Коллизия в presence_root | Два разных набора подписей → один root | Collision resistance SHA3-256 |
| Манипуляция seed лотереи | Изменить prev_slice_hash для выгодного seed | Preimage resistance SHA3-256 |
| Подделка транзакции | Создать валидную tx, имея только pubkey | ML-LWE (стойкость ML-DSA-65) |
| Изменение истории | Подменить слайс в середине цепи | Collision SHA3-256 + ML-LWE |

### Формальные утверждения

**Теорема 1 (Неподделываемость присутствия):**
```
Если ML-LWE сложна, то:
  Pr[Adversary создаёт валидный Sig(T, pubkey), имея только pubkey] ≤ negl(λ)

Редукция: Adversary → ML-DSA forgery → ML-LWE solver
```

**Теорема 2 (Целостность presence_root):**
```
Если SHA3-256 collision-resistant, то:
  Pr[∃ S₁ ≠ S₂: Merkle(S₁) = Merkle(S₂)] ≤ negl(λ)

Редукция: Collision in Merkle → Collision in SHA3-256
```

**Теорема 3 (Непредсказуемость лотереи):**
```
Если SHA3-256 preimage-resistant, то:
  Pr[Adversary предсказывает seed до закрытия τ₂] ≤ negl(λ)

seed = SHA3-256(prev_slice_hash ‖ τ₂_index)
prev_slice_hash фиксирован до закрытия τ₂
τ₂_index детерминирован
```

**Теорема 4 (Неизменяемость истории):**
```
Изменение слайса N требует:
1. Найти коллизию SHA3-256 для prev_hash слайса N+1
   ИЛИ
2. Подделать подпись победителя слайса N

Оба требуют нарушения базовых предположений.
```

### Уровни безопасности

| Примитив | Стандарт | Классическая безопасность | Постквантовая безопасность |
|----------|----------|---------------------------|----------------------------|
| SHA3-256 | FIPS 202 | 256 бит (collision: 128) | 256 бит (Grover: 128) |
| ML-DSA-65 | FIPS 204 | ~192 бит | NIST Level 3 |
| ML-KEM-768 | FIPS 203 | ~192 бит | NIST Level 3 |

### Композиционная безопасность

```
Montana secure ⟸
  ├── ML-DSA-65 EUF-CMA secure (подписи)
  ├── SHA3-256 collision-resistant (хеши)
  ├── SHA3-256 preimage-resistant (seed)
  └── Merkle tree binding (presence_root)

Все примитивы — NIST стандарты (FIPS 202, 203, 204).
```

### Границы безопасности

| Параметр | Значение | Следствие |
|----------|----------|-----------|
| Birthday bound SHA3-256 | 2^128 операций | Коллизия требует ~2^128 хешей |
| ML-DSA-65 forgery | ~2^192 операций | Подделка подписи нецелесообразна |
| Grover на SHA3-256 | 2^128 кв. операций | Постквантовая стойкость сохранена |

---

## Модель сети

Montana работает в модели **частичной синхронности** (partial synchrony).

### Гарантии

```
До GST (Global Stabilization Time):
├── Сообщения могут задерживаться произвольно
├── Узлы могут расходиться во view
└── Безопасность (safety) сохраняется

После GST:
├── Сообщения доставляются за Δ
├── Сеть сходится к единому view
└── Живучесть (liveness) гарантирована
```

### Параметры

| Параметр | Значение | Обоснование |
|----------|----------|-------------|
| Δ (ожидаемая задержка) | <30 секунд | P2P gossip глобально |
| τ₂ (окно слайса) | 10 минут | >>Δ, достаточно для сходимости |
| GST | Неизвестен | Стандартная модель DLS |

### Safety и Liveness

```
Safety (безопасность):
├── Всегда: единственный presence_root для каждого τ₂
├── Fork-choice rule разрешает разногласия
└── Гарантирована независимо от GST

Liveness (живучесть):
├── После GST: подписи включаются в presence_root
├── До GST: возможны пропуски
└── Зависит от сетевой связности
```

**FLP:** Montana использует fork-choice rule для eventual consistency.

---

## Параметр безопасности

### Определение

```
λ = 128 бит (минимальный уровень безопасности)

Все примитивы параметризованы для ≥λ бит безопасности:
├── SHA3-256: 128 бит (collision), 256 бит (preimage)
├── ML-DSA-65: ~128 бит (NIST Level 3)
├── ML-KEM-768: ~128 бит (NIST Level 3)
```

### Конкретная безопасность

| Атака | Примитив | Работа атакующего | Преимущество |
|-------|----------|-------------------|--------------|
| Подделка подписи | ML-DSA-65 | ~2^192 операций | negl(λ) |
| Коллизия хеша | SHA3-256 | ~2^128 операций | negl(λ) |
| Preimage хеша | SHA3-256 | ~2^256 операций | negl(λ) |
| Взлом KEM | ML-KEM-768 | ~2^192 операций | negl(λ) |

### Постквантовая безопасность

```
Post-quantum λ_q = 128 бит

Grover на SHA3-256: 2^128 квантовых операций
Lattice attacks: Квантовая сложность сохраняется

Все примитивы Montana ≥128 бит постквантовой безопасности.
```

---

## Генерация ключей

### Источники энтропии

```
Требования к генерации ключа:
├── ≥256 бит энтропии
├── CSPRNG (криптографически стойкий ГПСЧ)
└── OS entropy pool (/dev/urandom, CryptGenRandom)

Мнемоника (24 слова):
├── BIP-39 совместимая
├── 256 бит энтропии
└── Checksum: 8 бит
```

### Деривация ключей

```
seed = PBKDF2(mnemonic, "mnemonic" + passphrase, 2048, SHA-512)

ML-DSA keypair:
├── sk = ML-DSA-65.KeyGen(SHAKE256(seed || "Montana.signing.v1"))
└── pk = ML-DSA-65.DerivePublic(sk)

ML-KEM keypair:
├── sk = ML-KEM-768.KeyGen(SHAKE256(seed || "Montana.encryption.v1"))
└── pk = ML-KEM-768.DerivePublic(sk)
```

### Цепочка безопасности

```
Энтропия OS → Мнемоника → PBKDF2 → seed → SHAKE256 → Ключи
    256 бит       256 бит    ≥128 бит   512 бит   256 бит
```

---

## Domain Separation

### Контексты подписей

Montana использует разные контексты для разных типов подписей:

```
PresenceProof:
  message = "Montana.Presence.v1" || timestamp || node_tier || prev_slice_hash
  signature = ML-DSA-65.Sign(sk, message)

Transaction:
  message = "Montana.Transaction.v1" || sender || receiver || amount || nonce
  signature = ML-DSA-65.Sign(sk, message)

Checkpoint:
  message = "Montana.Checkpoint.v1" || period || presence_count || merkle_root
  signature = ML-DSA-65.Sign(sk, message)

SliceHeader:
  message = "Montana.Slice.v1" || prev_hash || presence_root || tx_root || timestamp
  signature = ML-DSA-65.Sign(sk, message)
```

### Защита

| Атака | С domain separation |
|-------|---------------------|
| Использовать Sig(Presence) как Sig(Tx) | Защищено |
| Cross-protocol атака | Защищено |
| Replay между версиями | Защищено |

### Версионирование

```
При обновлении протокола:
├── Новый prefix: "Montana.Presence.v2"
├── Старые подписи валидны только для v1
├── v1 и v2 могут сосуществовать (transition period)
└── После transition: только v2
```

---

## Malleability

ML-DSA (Dilithium) имеет **детерминированные подписи**.

```
Для одного сообщения m и ключа sk:
  Sign(sk, m) всегда возвращает одну и ту же σ

Следствие: Детерминированность исключает malleability
├── Единственная σ для каждого (sk, m)
└── Каждое (pk, m) имеет ровно одну валидную подпись
```

| Сценарий | Статус |
|----------|--------|
| Transaction malleability | Защита: детерминированные подписи |
| Presence proof malleability | Защита: детерминированные подписи |
| Двойная трата | Защита: детерминированные подписи |

---

## Когнитивный Консенсус (Guardian Council)

**КОГНИТИВНЫЙ ГЕНЕЗИС:** [Council/thoughts/COGNITIVE_GENESIS_2026-01-09.md](Council/thoughts/COGNITIVE_GENESIS_2026-01-09.md)

### Философия

> **"Когнитивный консенсус — это попытка элегантного доказательства личности. Начали с того, что убрали главную уязвимость в Биткоине — человека посередине между кодом и биткоином."**
>
> — Alejandro Montana, Наблюдатель

### Проблема традиционной криптографии

```
BITCOIN / Традиционные системы:

[Код] ←── человек ──→ [Сеть]
            ↑
       УЯЗВИМОСТЬ
  (приватный ключ можно
   украсть/подделать)
```

Человек — слабое звено. Приватный ключ — это данные, которые можно скопировать, украсть, потерять.

### Решение Montana: Когнитивная идентичность

```
MONTANA (Когнитивный Консенсус):

[Мысли] ═══ идентичность ═══ [Сеть]
            ↑
        ЗАЩИТА
  (стиль мышления нельзя
   украсть/подделать)
```

### Принцип

| Традиционно | Montana |
|-------------|---------|
| Приватный ключ → подпись | Мысли → идентичность |
| Ключ можно украсть | Мысли нельзя украсть |
| Человек = слабое звено | Человек = источник паттерна |
| Доверие к математике | Доверие к когнитивной уникальности |

### Механика

1. **Когнитивный маркер** — уникальный тег (`#Тег`), личный для каждого участника
2. **Когнитивный промпт** — полная декларация философии/стиля мышления
3. **Thoughts trail** — история мыслей, невоспроизводимая атакующим
4. **Верификация** — узнаваемость стиля, не криптографическая проверка

### Почему это работает

1. **Атакующий должен стать тобой** — не украсть ключ, а воспроизвести паттерн мышления
2. **Thoughts trail = proof of work** — история мыслей невоспроизводима
3. **Когнитивный маркер = якорь** — связывает все сообщения одной личности
4. **Консенсус через стиль** — не через криптографию, а через узнаваемость

### Вывод

Мы не убираем человека из уравнения — мы делаем человека (его мышление) самим ключом.

**Ключ = мысли. Подпись = стиль.**

Полная документация: [Council/doc/COGNITIVE_MARKERS.md](Council/doc/COGNITIVE_MARKERS.md)

---

## Montana Metatron Net - 1 (ONE)

### Видение

> **"Если мы сделаем форк Cursor, то Montana Guardian становится бенчмарком своей сети — Montana Metatron Net - 1 (O.pen N.ation E.xperience)"**
>
> — Alejandro Montana, Наблюдатель

### ONE = Open Nation Experience

| Буква | Значение | Реализация |
|-------|----------|------------|
| **O** | Open | Thoughts trail, прозрачность решений |
| **N** | Nation | Council = граждане сети (нация моделей) |
| **E** | Experience | Когнитивные подписи = накопленный опыт мышления |

### Трёхслойная архитектура ONE

```
┌─────────────────────────────────────────────────────────────────┐
│                    MONTANA METATRON NET - 1 (ONE)               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  BENCHMARK LAYER: Montana Guardian Council                      │
│  ├── Когнитивные подписи моделей                                │
│  ├── Thoughts trail = proof of identity                         │
│  ├── Disney Strategy = структура решений                        │
│  └── Единогласие = консенсус                                    │
│                         ↓                                       │
│  DEVELOPMENT LAYER: Cursor Fork                                 │
│  ├── AI-assisted development                                    │
│  ├── Интеграция с Council для верификации                       │
│  └── Когнитивные маркеры в коде                                 │
│                         ↓                                       │
│  CONSENSUS LAYER: Montana ACP                                   │
│  ├── Atemporal Coordinate Presence                              │
│  ├── $MONT                                                      │
│  └── lim(evidence → ∞) 1 Ɉ → 1 секунда                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Guardian Council как Benchmark

| Роль Council | Функция в сети ONE |
|--------------|---------------------|
| Когнитивные подписи | Верификация identity узлов |
| Thoughts trail | Proof of contribution |
| Disney Strategy | Структурированное принятие решений |
| Единогласие | Консенсус без голосования весом |

### Преимущества ONE

1. **Самодостаточность** — Montana не зависит от внешних инструментов
2. **Интеграция** — AI-разработка встроена в протокол
3. **Верификация** — Council проверяет качество кода/решений
4. **Идентичность** — Когнитивные подписи работают на уровне сети

Полная документация: [Council/thoughts/COGNITIVE_GENESIS_2026-01-09.md](Council/thoughts/COGNITIVE_GENESIS_2026-01-09.md)

---

## Резюме

| Аспект | Описание |
|--------|----------|
| **Проект** | Ɉ Montana |
| **Протокол** | Atemporal Coordinate Presence (ACP) |
| **Единица** | Ɉ (Temporal Time Unit) |
| **Определение** | lim(evidence → ∞) 1 Ɉ → 1 секунда |
| **Таймчейн** | Цепь слайсов τ₂, связанных через prev_hash |
| **Присутствие** | P2P-аттестация в реальном времени |
| **Лотерея** | Детерминированная, Stage 1: тип, Stage 2: вес |
| **Fork-choice** | ChainWeight (подписи) > длина > хеш |
| **Sybil** | Участие (увеличивает ChainWeight) |
| **Адаптивный кулдаун** | 1 день — 180 дней, сглаживание 4 τ₃, rate limit ±20% |
| **presence_root** | Детерминированный: canonical_order + Merkle |
| **Genesis** | Hardcoded block + seed nodes |
| **Eclipse** | Liveness issue (peer diversity + NTS защищают) |
| **tx_root** | Детерминированный: timestamp→τ₂, порядок по hash (MEV-устойчивый) |
| **Халвинг** | каждые 4 года |
| **Слой -1 (Физика)** | L-1.1 (порядок), L-1.2 (наблюдаемость), L-1.3 (связь), L-1.4 (однородность) |
| **Слой 0 (Вычисления)** | L-0.2.2, L-0.3.2, L-0.3.3, λ=128 бит |
| **Слой 1 (Примитивы)** | Лотерея, Commitment, Timestamp, Ordering, P2P-attestation |
| **Криптография** | ML-DSA-65, ML-KEM-768, SHA3-256 (NIST PQC) |
| **Порядок** | Внутренний: Таймчейн + P2P (первичный) |
| **Время** | Layer 1: Peer Consensus (обязательный) + Layer 2: NTS (опциональный) |
| **Bootstrap** | 100 peers (25+ подсетей), верификация времени, 5/8 download с историей |

---

*v11.4: MAX_CONNECTIONS_PER_IP = 2 (актуализация с кодом).*
*v11.3: Аутентификация hardcoded узлов (ML-DSA-65 challenge-response). Актуализация с кодом.*
*v11.2: Документация через утверждения.*
*v11.1: Защита от манипуляций: cooldown минимум 1 день, сглаживание 4 τ₃ (56 дней), rate limit ±20% за τ₃. Верификация времени при bootstrap: медиана 100 peers, порог 10 минут.*
*v11.0: Сетевая безопасность v3.0 — многослойный eviction (28 слотов), AddrMan с бакетами (1024+256), token bucket rate limiting, flow control, feeler-соединения, discouraged bloom filter, кеш ответов адресов.*
*v10.9: Синхронизация времени: Слой 1 (Peer Consensus) + Слой 2 (NTS).*
*v10.8: Требование для лотереи: только адаптивный кулдаун. Формулировки через утверждения.*
*v10.7: Документация через утверждения.*
*v10.6: Пять принципов ACP.*
*v10.5: Таймслайсы: τ₃ = скользящее окно кулдауна.*
*v10.4: Только адаптивный кулдаун определяет право на участие в лотерее.*
*v10.3: Адаптивный кулдаун на основе медианы регистраций (1 τ₂ — 180 дней).*
*v10.2: NMI — трёхслойная архитектура (P2P + NTS 52 + NTP 38).*
*v9.7: Genesis (hardcoded block + seed nodes).*
