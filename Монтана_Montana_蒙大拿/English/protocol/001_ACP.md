# Atemporal Coordinate Presence (ACP)

**Presence-Based Consensus Protocol**
**Montana Protocol v1.0**

**Status:** ✅ Implemented in Python

---

## Abstract

ACP — a consensus mechanism where proof is based on **presence in time**. Time cannot be accelerated, bought, or accumulated in advance. 14 days require 14 days — the same for everyone. Emission halves every τ₄ (4 years).

**Key Formula:**
```
1 second of presence = 1 Ɉ × halving_coefficient
```

---

## 1. Protocol Constants

**Source Code:** [time_bank.py:44-80](../бот/time_bank.py#L44-L80)

```python
class Protocol:
    """TIME_BANK v3.0 Protocol Constants"""
    VERSION = "3.0"

    # Network
    NODES_COUNT = 5                        # 5 Montana nodes
    BANK_PRESENCE_PER_T2 = 600             # Bank present 600 sec (10 min)
    TOTAL_EMISSION_PER_T2 = 15000          # For backward compatibility

    # Temporal Coordinates
    TAU1_INTERVAL_SEC = 60                 # τ₁ = 1 minute — signature interval
    T2_DURATION_SEC = 10 * 60              # τ₂ = 10 minutes = 600 seconds (slice)
    TAU3_DURATION_SEC = 14 * 24 * 60 * 60  # τ₃ = 14 days = 1,209,600 sec
    TAU4_DURATION_SEC = 4 * 365 * 24 * 60 * 60  # τ₄ = 4 years (halving epoch)

    # Hierarchy
    T2_PER_TAU3 = 2016                     # 2016 × τ₂ in τ₃
    TAU3_PER_YEAR = 26                     # 26 × τ₃ per year
    TAU3_PER_TAU4 = 104                    # 104 × τ₃ in τ₄

    # Coins
    COINS_PER_SECOND = 1                   # 1 second = 1 Ɉ
    INACTIVITY_LIMIT_SEC = 3 * 60          # 3 minutes without activity = pause

    # Presence Proof
    PRESENCE_PROOF_VERSION = "MONTANA_PRESENCE_V1"
    GENESIS_HASH = "0" * 64                # Genesis prev_hash
```

### 1.1 Temporal Units Table

| Unit | Value | In Seconds |
|------|-------|------------|
| τ₁ | 1 minute | 60 |
| τ₂ | 10 minutes | 600 |
| τ₃ | 14 days | 1,209,600 |
| τ₄ | 4 years | 126,144,000 |

### 1.2 Hierarchy

```
1 τ₄ = 104 τ₃ = 209,664 τ₂ = 126,144,000 seconds
1 τ₃ = 2016 τ₂ = 1,209,600 seconds
1 τ₂ = 600 seconds = 600 Ɉ (base)
```

---

## 2. Halving — Emission

### 2.1 Halving Algorithm

**Source Code:** [time_bank.py:82-107](../бот/time_bank.py#L82-L107)

```python
def halving_coefficient(tau4_count: int) -> float:
    """
    Halving coefficient — division by 2 every τ₄ (4 years)

    Args:
        tau4_count: Number of passed τ₄ epochs

    Returns:
        Emission coefficient (1.0, 0.5, 0.25, 0.125...)

    Formula:
        emission_per_second = 1.0 / (2 ** tau4_count)
    """
    return 1.0 / (2 ** tau4_count)
```

### 2.2 Halving Schedule

| τ₄ | Period | Coefficient | 1 sec = |
|----|--------|-------------|---------|
| 0 | Years 1-4 | 1.0 | 1.0 Ɉ |
| 1 | Years 5-8 | 0.5 | 0.5 Ɉ |
| 2 | Years 9-12 | 0.25 | 0.25 Ɉ |
| 3 | Years 13-16 | 0.125 | 0.125 Ɉ |
| ... | ... | ... | ... |
| 64 | ~260 years | ~0 | ~0 Ɉ |

### 2.3 Mathematical Formulation

Let `n` be the τ₄ epoch number. Emission per 1 second of presence:

```
E(n) = 1 / 2ⁿ Ɉ

Where:
  n = 0: E(0) = 1.0 Ɉ/sec
  n = 1: E(1) = 0.5 Ɉ/sec
  n = 2: E(2) = 0.25 Ɉ/sec
```

---

## 3. Emission Mechanism

### 3.1 τ₂ Finalization

**Source Code:** [time_bank.py:529-602](../бот/time_bank.py#L529-L602)

```python
def _finalize_t2(self):
    """Finalizes T2, credits coins with halving"""
    self.t2_count += 1

    # Calculate halving coefficient
    self.current_halving_coefficient = halving_coefficient(self.tau4_count)

    # Count total seconds of presence
    total_users_seconds = 0
    for address, entry in self.presence.all().items():
        total_users_seconds += entry["t2_seconds"]

    # Distribute: each user gets their seconds × halving
    for address, entry in self.presence.all().items():
        if entry["t2_seconds"] > 0:
            coins = int(entry["t2_seconds"] * self.current_halving_coefficient)
            self.db.credit(address, coins, entry.get("addr_type", "unknown"))
            entry["t2_seconds"] = 0
```

### 3.2 Parallel Distribution

```
┌─────────────────────────────────────────────────────────────┐
│                    MONTANA EMISSION                          │
├─────────────────────────────────────────────────────────────┤
│  τ₄ = 0 (first 4 years)                                     │
│  halving_coefficient = 1.0                                  │
├─────────────────────────────────────────────────────────────┤
│  User A       │ +600 sec × 1.0 = │ +600 Ɉ                   │
│  User B       │ +450 sec × 1.0 = │ +450 Ɉ                   │
│  User C       │ +600 sec × 1.0 = │ +600 Ɉ                   │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│  τ₄ = 1 (years 5-8)                                          │
│  halving_coefficient = 0.5                                  │
├─────────────────────────────────────────────────────────────┤
│  User A       │ +600 sec × 0.5 = │ +300 Ɉ                   │
│  User B       │ +450 sec × 0.5 = │ +225 Ɉ                   │
│  User C       │ +600 sec × 0.5 = │ +300 Ɉ                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. Presence Proof (ML-DSA-65)

### 4.1 Presence Signature

**Source Code:** [time_bank.py:271-327](../бот/time_bank.py#L271-L327)

Every τ₁ (1 minute) the node signs a presence proof:

```python
def _sign_presence_proof(self) -> Optional[Dict[str, Any]]:
    """Signs presence proof every τ₁"""
    timestamp = int(time.time())
    t2_index = self.t2_count

    # Form message
    message = f"{Protocol.PRESENCE_PROOF_VERSION}:{timestamp}:{self._last_proof_hash}:{self._node_public_key}:{t2_index}"

    # Sign with ML-DSA-65
    signature = sign_message(self._node_private_key, message)

    # Hash for proof chain
    proof_hash = hashlib.sha256(
        f"{message}:{signature}".encode('utf-8')
    ).hexdigest()
```

### 4.2 Message Format

```
MONTANA_PRESENCE_V1:{timestamp}:{prev_hash}:{pubkey}:{t2_index}
```

### 4.3 Proof Chain

```
┌─────────────────────────────────────────────────────────────┐
│  PRESENCE PROOF CHAIN                                       │
├─────────────────────────────────────────────────────────────┤
│  Genesis    │ prev_hash = "0000...0000" (64 zeros)          │
│  Proof #1   │ prev_hash = Genesis.hash                      │
│  Proof #2   │ prev_hash = Proof#1.hash                      │
│  ...        │ ...                                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 5. ML-DSA-65 Cryptography

### 5.1 Parameters

| Parameter | Value |
|-----------|-------|
| Algorithm | ML-DSA-65 (Dilithium) |
| Standard | FIPS 204 |
| Level | NIST Level 3 (128-bit post-quantum) |
| Private Key | 4032 bytes |
| Public Key | 1952 bytes |
| Signature | 3309 bytes |

### 5.2 Integration

**Source Code:** [time_bank.py:31-35](../бот/time_bank.py#L31-L35)

```python
try:
    from node_crypto import sign_message, verify_signature, get_node_crypto_system
    ML_DSA_AVAILABLE = True
except ImportError:
    ML_DSA_AVAILABLE = False
```

---

## 6. Checkpoints

### 6.1 τ₃ Checkpoint (14 days)

**Source Code:** [time_bank.py:573-583](../бот/time_bank.py#L573-L583)

```python
# Check τ₃ checkpoint (every 2016 T2 = 14 days)
if self.t2_count % Protocol.T2_PER_TAU3 == 0:
    self.tau3_count += 1
    logger.info(f"τ₃ CHECKPOINT #{self.tau3_count} — 14 DAYS PASSED")
```

### 6.2 τ₄ Halving (4 years)

**Source Code:** [time_bank.py:585-594](../бот/time_bank.py#L585-L594)

```python
# Check τ₄ epoch (every 104 τ₃ = 4 years) — HALVING!
if self.tau3_count > 0 and self.tau3_count % Protocol.TAU3_PER_TAU4 == 0:
    self.tau4_count += 1
    logger.info(f"τ₄ HALVING #{self.tau4_count} — EMISSION ÷ 2")
```

---

## 7. API

### 7.1 Presence Management

```python
from time_bank import get_time_bank

bank = get_time_bank()

# Start presence
bank.start("user_123", "telegram")

# Register activity
bank.activity("user_123")

# End presence
bank.end("user_123")
```

### 7.2 Wallet

**Source Code:** [time_bank.py:381-419](../бот/time_bank.py#L381-L419)

```python
# Confirmed balance
balance = bank.balance("user_123")

# Balance with pending (not yet confirmed in T2)
balance_info = bank.get_balance_with_pending("user_123")
# {
#     "confirmed": 1000,   # In DB
#     "pending": 45,       # Accumulating in current T2
#     "total": 1045        # Sum
# }

# Transfer
result = bank.send("from_addr", "to_addr", 100)

# Transaction history
txs = bank.my_txs("user_123", limit=50)
```

### 7.3 Presence Proofs

```python
# Set node keys
bank.set_node_keys(private_key_hex, public_key_hex)

# Get latest proofs
proofs = bank.get_presence_proofs(limit=10)

# Verify proof
is_valid = bank.verify_presence_proof(proof)

# Chain status
status = bank.get_proof_chain_status()
```

---

## 8. Attack Protection

| Attack | Defense Mechanism | Status |
|--------|-------------------|--------|
| Quantum | ML-DSA-65 post-quantum | ✅ Implemented |
| IP hijacking | Cryptographic addresses | ✅ Implemented |
| Harvest now decrypt later | ML-DSA-65 from genesis | ✅ Implemented |
| Time manipulation | τ₁ signatures every minute | ✅ Implemented |
| Sybil | Adaptive Cooldown | ✅ Implemented |

---

## 9. Implementation

| Component | File | Status |
|-----------|------|--------|
| TimeBank | [time_bank.py](../бот/time_bank.py) | ✅ Working |
| Protocol constants | [time_bank.py:44-80](../бот/time_bank.py#L44-L80) | ✅ Working |
| halving_coefficient | [time_bank.py:82-107](../бот/time_bank.py#L82-L107) | ✅ Working |
| Presence Proof | [time_bank.py:271-327](../бот/time_bank.py#L271-L327) | ✅ Working |
| τ₃/τ₄ checkpoints | [time_bank.py:573-594](../бот/time_bank.py#L573-L594) | ✅ Working |
| get_balance_with_pending | [time_bank.py:388-415](../бот/time_bank.py#L388-L415) | ✅ Working |
| ML-DSA-65 keys | [node_crypto.py](../бот/node_crypto.py) | ✅ Working |

---

## 10. Testing

```bash
# Statistics
python time_bank.py stats

# Demo
python time_bank.py demo

# Balance
python time_bank.py balance <address>

# Presence proofs
python time_bank.py proofs
python time_bank.py proof-status
```

---

```
Alejandro Montana
Montana Protocol v1.0
January 2026
```
