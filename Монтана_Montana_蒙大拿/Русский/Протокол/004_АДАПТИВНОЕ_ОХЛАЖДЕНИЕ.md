# Adaptive Cooldown

**Адаптивный период ожидания Montana**
**Montana Protocol v1.0**

**Статус:** ✅ Реализовано в Python

---

## Абстракт

Adaptive Cooldown — механизм динамической защиты от Sybil-атак посредством адаптивного периода ожидания для новых узлов сети. Период ожидания вычисляется на основе сглаженной медианы регистраций за последние 56 дней (4 × τ₃). Диапазон: от 1 дня при низкой нагрузке до 180 дней при аномальном спайке. Стоимость Sybil-атаки определяется формулой:

```
Sybil_cost = cooldown × N_nodes
```

где `cooldown ∈ [1, 180]` дней, `N_nodes` — количество атакующих узлов.

---

## 1. Константы протокола

**Исходный код:** [adaptive_cooldown.py:28-52](../бот/adaptive_cooldown.py#L28-L52)

```python
@dataclass(frozen=True)
class CooldownConstants:
    # Временные единицы (в τ₂ слайсах, 1 τ₂ = 10 минут)
    TAU2_DURATION_SEC: int = 600           # τ₂ = 10 минут
    TAU3_IN_TAU2: int = 2016               # τ₃ = 14 дней = 2016 τ₂

    # Границы cooldown (в τ₂)
    COOLDOWN_MIN_TAU2: int = 144           # 1 день
    COOLDOWN_MID_TAU2: int = 1008          # 7 дней
    COOLDOWN_MAX_TAU2: int = 25920         # 180 дней

    # Сглаживание и rate limiting
    SMOOTH_WINDOWS: int = 4                # 4 × τ₃ = 56 дней
    MAX_CHANGE_PERCENT: int = 20           # ±20% за τ₃

    # Genesis
    DEFAULT_COOLDOWN_TAU2: int = 144       # 1 день
```

### 1.1 Таблица границ

| Параметр | Значение τ₂ | Значение в днях |
|----------|-------------|-----------------|
| `COOLDOWN_MIN` | 144 | 1 |
| `COOLDOWN_MID` | 1008 | 7 |
| `COOLDOWN_MAX` | 25920 | 180 |

### 1.2 Преобразование единиц

```
1 день = 144 τ₂ = 24 × 6 τ₂ = 24 часа × 6 слайсов/час
1 τ₃ = 2016 τ₂ = 14 дней
```

---

## 2. Алгоритм вычисления cooldown

### 2.1 Основная формула

**Исходный код:** [adaptive_cooldown.py:202-231](../бот/adaptive_cooldown.py#L202-L231)

```python
def _calculate_raw_cooldown(self, current_count: int, median: int) -> int:
    ratio = current_count / median

    if ratio <= 1.0:
        # Линейная интерполяция: MIN → MID
        cooldown = COOLDOWN_MIN_TAU2 + ratio * (COOLDOWN_MID_TAU2 - COOLDOWN_MIN_TAU2)
    else:
        # Линейная интерполяция: MID → MAX
        cooldown = COOLDOWN_MID_TAU2 + (ratio - 1.0) * (COOLDOWN_MAX_TAU2 - COOLDOWN_MID_TAU2)

    return int(max(COOLDOWN_MIN_TAU2, min(COOLDOWN_MAX_TAU2, cooldown)))
```

### 2.2 Математическая формулировка

Пусть:
- `r = current_count / smoothed_median` — коэффициент нагрузки
- `C_min = 1` день, `C_mid = 7` дней, `C_max = 180` дней

Тогда cooldown `C(r)` определяется кусочно-линейной функцией:

```
         ⎧ C_min + r × (C_mid - C_min),           если r ≤ 1
C(r) =   ⎨
         ⎩ C_mid + (r - 1) × (C_max - C_mid),     если r > 1
```

### 2.3 Таблица значений

| Коэффициент r | Cooldown (дней) |
|---------------|-----------------|
| 0.0 | 1 |
| 0.5 | 4 |
| 1.0 | 7 |
| 1.5 | 93.5 |
| 2.0 | 180 |

---

## 3. Сглаживание медианы

### 3.1 Алгоритм

**Исходный код:** [adaptive_cooldown.py:170-200](../бот/adaptive_cooldown.py#L170-L200)

```python
def _compute_smoothed_median(self, current_tau3: int, tier: int) -> int:
    """Вычислить сглаженную медиану за 4 τ₃ (56 дней)"""
    medians = []

    for i in range(SMOOTH_WINDOWS):  # SMOOTH_WINDOWS = 4
        tau3_idx = current_tau3 - i
        if tau3_idx < 0:
            continue

        key = (tau3_idx, tier)
        if key in self._median_history:
            medians.append(self._median_history[key])
        else:
            count = self.get_registrations_count(tau3_idx, tier)
            if count > 0:
                medians.append(count)

    if not medians:
        return 1

    return max(1, int(statistics.mean(medians)))
```

### 3.2 Цель сглаживания

Скользящее среднее за 4 × τ₃ (56 дней) предотвращает манипуляцию cooldown через краткосрочные спайки регистраций.

---

## 4. Rate Limiting

### 4.1 Механизм

**Исходный код:** [adaptive_cooldown.py:233-249](../бот/adaptive_cooldown.py#L233-L249)

```python
def _apply_rate_limit(self, raw_cooldown: int, previous_cooldown: int) -> int:
    """Ограничить изменение cooldown до ±20% за τ₃"""
    max_change = (previous_cooldown * MAX_CHANGE_PERCENT) // 100

    if raw_cooldown > previous_cooldown:
        return min(raw_cooldown, previous_cooldown + max_change)
    else:
        return max(raw_cooldown, previous_cooldown - max_change)
```

### 4.2 Пример

При `previous_cooldown = 144 τ₂` (1 день):
- Максимальное увеличение: `144 + 144 × 0.20 = 172.8 ≈ 172 τ₂`
- Максимальное уменьшение: `144 - 144 × 0.20 = 115.2 ≈ 115 τ₂`

---

## 5. Обработка завершения τ₃

**Исходный код:** [adaptive_cooldown.py:251-281](../бот/adaptive_cooldown.py#L251-L281)

```python
def on_tau3_end(self, tau3_index: int):
    """Пересчёт cooldown при завершении τ₃"""
    for tier in range(1, 5):
        # 1. Получить текущее количество регистраций
        current_count = self.get_registrations_count(tau3_index, tier)

        # 2. Сохранить в историю медиан
        self._median_history[(tau3_index, tier)] = max(1, current_count)

        # 3. Вычислить сглаженную медиану
        smoothed_median = self._compute_smoothed_median(tau3_index, tier)

        # 4. Рассчитать raw cooldown
        raw_cooldown = self._calculate_raw_cooldown(current_count, smoothed_median)

        # 5. Применить rate limit
        previous = self._current_cooldown.get(tier, DEFAULT_COOLDOWN_TAU2)
        new_cooldown = self._apply_rate_limit(raw_cooldown, previous)

        # 6. Сохранить новый cooldown
        self._current_cooldown[tier] = new_cooldown
```

---

## 6. API

### 6.1 Регистрация узла

```python
from adaptive_cooldown import get_adaptive_cooldown

cooldown = get_adaptive_cooldown()
cd_tau2 = cooldown.register_node("mta46b633d...", tier=1)
print(f"Cooldown: {cd_tau2 // 144} дней")
```

### 6.2 Проверка статуса

```python
# Находится ли узел в cooldown?
in_cooldown = cooldown.is_in_cooldown(registration_tau2=100, tier=1)

# Оставшийся cooldown
remaining = cooldown.cooldown_remaining(registration_tau2=100, tier=1)
```

### 6.3 Статистика

```python
stats = cooldown.get_stats()
# {
#   "current_tau2": 2016,
#   "cooldowns": {"tier_1": {"tau2": 172, "days": 1.19}, ...},
#   "constants": {"min_days": 1, "max_days": 180, ...}
# }
```

---

## 7. Защита от атак

| Вектор атаки | Механизм защиты | Эффективность |
|--------------|-----------------|---------------|
| Spike manipulation | 56-дневное сглаживание | Высокая |
| Fast pump | ±20% rate limit за τ₃ | Высокая |
| Sybil (низкая нагрузка) | Минимум 1 день | Гарантировано |
| Sybil (спайк) | До 180 дней | Линейный рост стоимости |

### 7.1 Стоимость Sybil-атаки

Для создания N фальшивых узлов атакующий должен потратить:

```
T_total = Σ cooldown_i для i = 1..N
```

При стабильной нагрузке `cooldown ≈ 7 дней`:
- 10 узлов: 70 дней
- 100 узлов: 700 дней (≈ 2 года)
- 1000 узлов: 7000 дней (≈ 19 лет)

---

## 8. Реализация

| Компонент | Файл | Статус |
|-----------|------|--------|
| AdaptiveCooldown | [adaptive_cooldown.py](../бот/adaptive_cooldown.py) | ✅ Работает |
| CooldownConstants | [adaptive_cooldown.py:28-52](../бот/adaptive_cooldown.py#L28-L52) | ✅ Работает |
| Smoothed median | [adaptive_cooldown.py:170-200](../бот/adaptive_cooldown.py#L170-L200) | ✅ Работает |
| Rate limiting | [adaptive_cooldown.py:233-249](../бот/adaptive_cooldown.py#L233-L249) | ✅ Работает |

---

## 9. Тестирование

```bash
# Запуск тестов
python adaptive_cooldown.py test

# Симуляция нагрузки
python adaptive_cooldown.py simulate

# Статистика
python adaptive_cooldown.py stats
```

---

```
Alejandro Montana
Montana Protocol v1.0
Январь 2026
```
