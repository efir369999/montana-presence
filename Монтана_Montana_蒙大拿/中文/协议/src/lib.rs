//! # 非时间坐标存在协议 (ACP)
//!
//! Montana共识核心。依赖加密模块。
//!
//! ## 中文代码
//! 所有标识符使用中文，仿佛中文之魂所写。

use montana_crypto::{哈希256, 默克尔根, 密钥对, 域标签, 验证签名, 格式化域消息};

// ═══════════════════════════════════════════════════════════════════════════════
//                                 时间单位
// ═══════════════════════════════════════════════════════════════════════════════

/// 时间单位常量
pub mod 时间 {
    /// τ₁ = 1分钟（60秒）
    pub const 一分钟: u64 = 60;

    /// τ₂ = 10分钟（600秒）
    pub const 十分钟: u64 = 600;

    /// τ₂包含的τ₁数量
    pub const 分钟每切片: u64 = 10;

    /// τ₃ = 14天
    pub const 两周秒数: u64 = 14 * 24 * 60 * 60;

    /// τ₃包含的τ₂数量
    pub const 切片每纪元: u64 = 2016;

    /// τ₄ = 4年
    pub const 四年秒数: u64 = 4 * 365 * 24 * 60 * 60;

    /// τ₄包含的τ₃数量
    pub const 纪元每周期: u64 = 104;
}

// ═══════════════════════════════════════════════════════════════════════════════
//                                 存在证明
// ═══════════════════════════════════════════════════════════════════════════════

/// 存在证明结构
/// 证明节点在某时刻存在
#[derive(Clone, Debug)]
pub struct 存在证明 {
    /// 节点公钥
    pub 公钥: [u8; 32],

    /// 时间坐标τ₁（分钟索引）
    pub 分钟索引: u64,

    /// 切片索引τ₂
    pub 切片索引: u64,

    /// 存在签名
    pub 签名: [u8; 64],
}

impl 存在证明 {
    /// 创建存在证明
    pub fn 创建(钥匙对: &密钥对, 分钟: u64, 切片: u64) -> Self {
        let 消息 = Self::格式化消息(分钟, 切片);
        let 签名 = 钥匙对.域签名(域标签::存在证明, &消息);

        Self {
            公钥: 钥匙对.公钥,
            分钟索引: 分钟,
            切片索引: 切片,
            签名,
        }
    }

    /// 格式化签名消息
    fn 格式化消息(分钟: u64, 切片: u64) -> Vec<u8> {
        let mut 消息 = Vec::with_capacity(16);
        消息.extend_from_slice(&分钟.to_le_bytes());
        消息.extend_from_slice(&切片.to_le_bytes());
        消息
    }

    /// 验证存在证明
    pub fn 验证(&self, 当前切片: u64) -> bool {
        if self.切片索引 != 当前切片 {
            return false;
        }

        let 消息 = Self::格式化消息(self.分钟索引, self.切片索引);
        let 带标签 = 格式化域消息(域标签::存在证明, &消息);
        验证签名(&self.公钥, &带标签, &self.签名)
    }

    /// 计算证明哈希
    pub fn 哈希(&self) -> [u8; 32] {
        let mut 数据 = Vec::new();
        数据.extend_from_slice(&self.公钥);
        数据.extend_from_slice(&self.分钟索引.to_le_bytes());
        数据.extend_from_slice(&self.切片索引.to_le_bytes());
        数据.extend_from_slice(&self.签名);
        哈希256(&数据)
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
//                                 节点池
// ═══════════════════════════════════════════════════════════════════════════════

/// 节点池类型
/// 80/20 распределение (Full Nodes / Verified Users)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum 节点池 {
    /// 全节点 (80%概率) — Full Node с серверной инфраструктурой
    全节点,
    /// 验证用户 (20%概率) — Verified User с FIDO2/биометрией
    验证用户,
}

/// 参与者信息
#[derive(Clone, Debug)]
pub struct 参与者 {
    /// 公钥
    pub 公钥: [u8; 32],
    /// 节点池
    pub 池: 节点池,
    /// 权重（基于存在历史）
    pub 权重: u64,
}

// ═══════════════════════════════════════════════════════════════════════════════
//                                 确定性彩票
// ═══════════════════════════════════════════════════════════════════════════════

/// 确定性彩票结构
/// 选择切片胜者
pub struct 确定性彩票 {
    /// 随机种子
    种子: [u8; 32],
    /// 参与者列表
    参与者列表: Vec<参与者>,
}

impl 确定性彩票 {
    /// 创建彩票
    pub fn 新建(前切片哈希: &[u8; 32], 切片索引: u64, 参与者列表: Vec<参与者>) -> Self {
        let 种子 = Self::计算种子(前切片哈希, 切片索引);
        Self { 种子, 参与者列表 }
    }

    /// 计算种子
    pub fn 计算种子(前切片哈希: &[u8; 32], 切片索引: u64) -> [u8; 32] {
        let mut 数据 = Vec::with_capacity(40);
        数据.extend_from_slice(前切片哈希);
        数据.extend_from_slice(&切片索引.to_le_bytes());
        哈希256(&数据)
    }

    /// 选择胜者
    pub fn 选择胜者(&self) -> Option<&参与者> {
        if self.参与者列表.is_empty() {
            return None;
        }

        // 第一阶段：选择节点池 (80/20 распределение)
        let 池选择器 = self.种子[0] % 100;
        let 目标池 = match 池选择器 {
            0..=79 => 节点池::全节点,      // 80% → Full Nodes
            80..=99 => 节点池::验证用户,   // 20% → Verified Users
            _ => unreachable!(),
        };

        // 筛选目标池参与者
        let 池中参与者: Vec<&参与者> = self.参与者列表
            .iter()
            .filter(|p| p.池 == 目标池)
            .collect();

        if 池中参与者.is_empty() {
            return self.从全部选择();
        }

        // 第二阶段：加权选择
        let 总权重: u64 = 池中参与者.iter().map(|p| p.权重).sum();
        if 总权重 == 0 {
            return 池中参与者.first().copied();
        }

        let 目标哈希 = 哈希256(&[&self.种子[..], b"stage2"].concat());
        let 目标值 = u64::from_le_bytes(目标哈希[0..8].try_into().unwrap()) % 总权重;

        let mut 累计 = 0u64;
        for 参与者 in &池中参与者 {
            累计 += 参与者.权重;
            if 累计 > 目标值 {
                return Some(参与者);
            }
        }

        池中参与者.last().copied()
    }

    /// 从全部参与者选择
    fn 从全部选择(&self) -> Option<&参与者> {
        if self.参与者列表.is_empty() {
            return None;
        }

        let 总权重: u64 = self.参与者列表.iter().map(|p| p.权重).sum();
        if 总权重 == 0 {
            return self.参与者列表.first();
        }

        let 目标哈希 = 哈希256(&[&self.种子[..], b"fallback"].concat());
        let 目标值 = u64::from_le_bytes(目标哈希[0..8].try_into().unwrap()) % 总权重;

        let mut 累计 = 0u64;
        for 参与者 in &self.参与者列表 {
            累计 += 参与者.权重;
            if 累计 > 目标值 {
                return Some(参与者);
            }
        }

        self.参与者列表.last()
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
//                                 切片
// ═══════════════════════════════════════════════════════════════════════════════

/// 切片结构（Montana的"块"）
#[derive(Clone, Debug)]
pub struct 切片 {
    /// 切片索引
    pub 索引: u64,

    /// 前一切片哈希
    pub 前哈希: [u8; 32],

    /// 存在证明根
    pub 存在根: [u8; 32],

    /// 交易根
    pub 交易根: [u8; 32],

    /// 时间戳
    pub 时间戳: u64,

    /// 胜者公钥
    pub 胜者公钥: [u8; 32],

    /// 胜者签名
    pub 签名: [u8; 64],
}

impl 切片 {
    /// 创建新切片
    pub fn 创建(
        索引: u64,
        前哈希: [u8; 32],
        存在证明列表: &[存在证明],
        交易哈希列表: &[[u8; 32]],
        胜者钥匙对: &密钥对,
    ) -> Self {
        let 存在哈希列表: Vec<[u8; 32]> = 存在证明列表.iter().map(|p| p.哈希()).collect();
        let 存在根 = 默克尔根(&存在哈希列表);
        let 交易根 = 默克尔根(交易哈希列表);

        let 时间戳 = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();

        let mut 新切片 = Self {
            索引,
            前哈希,
            存在根,
            交易根,
            时间戳,
            胜者公钥: 胜者钥匙对.公钥,
            签名: [0u8; 64],
        };

        let 消息 = 新切片.签名消息();
        新切片.签名 = 胜者钥匙对.域签名(域标签::切片, &消息);

        新切片
    }

    /// 获取签名消息
    fn 签名消息(&self) -> Vec<u8> {
        let mut 消息 = Vec::new();
        消息.extend_from_slice(&self.索引.to_le_bytes());
        消息.extend_from_slice(&self.前哈希);
        消息.extend_from_slice(&self.存在根);
        消息.extend_from_slice(&self.交易根);
        消息.extend_from_slice(&self.时间戳.to_le_bytes());
        消息
    }

    /// 计算切片哈希
    pub fn 哈希(&self) -> [u8; 32] {
        let mut 数据 = self.签名消息();
        数据.extend_from_slice(&self.胜者公钥);
        数据.extend_from_slice(&self.签名);
        哈希256(&数据)
    }

    /// 验证切片
    pub fn 验证(&self, 前切片: &切片) -> bool {
        if self.索引 != 前切片.索引 + 1 {
            return false;
        }

        if self.前哈希 != 前切片.哈希() {
            return false;
        }

        let 消息 = self.签名消息();
        let 带标签 = 格式化域消息(域标签::切片, &消息);
        验证签名(&self.胜者公钥, &带标签, &self.签名)
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
//                                 时间链
// ═══════════════════════════════════════════════════════════════════════════════

/// 时间链结构
pub struct 时间链 {
    /// 切片列表
    切片列表: Vec<切片>,
}

impl 时间链 {
    /// 创建新时间链
    pub fn 新建(创世切片: 切片) -> Self {
        Self {
            切片列表: vec![创世切片],
        }
    }

    /// 添加切片
    pub fn 添加切片(&mut self, 新切片: 切片) -> bool {
        if let Some(前) = self.切片列表.last() {
            if 新切片.验证(前) {
                self.切片列表.push(新切片);
                return true;
            }
        }
        false
    }

    /// 获取最新切片
    pub fn 顶端(&self) -> Option<&切片> {
        self.切片列表.last()
    }

    /// 获取链长度
    pub fn 长度(&self) -> usize {
        self.切片列表.len()
    }

    /// 是否为空
    pub fn 是否为空(&self) -> bool {
        self.切片列表.is_empty()
    }

    /// 计算总存在权重
    pub fn 总存在权重(&self) -> u64 {
        self.切片列表.len() as u64
    }
}

/// 分叉选择
pub fn 分叉选择<'a>(链列表: &'a [时间链]) -> Option<&'a 时间链> {
    链列表.iter().max_by_key(|c| c.总存在权重())
}

// ═══════════════════════════════════════════════════════════════════════════════
//                           兼容性别名 (供其他模块使用)
// ═══════════════════════════════════════════════════════════════════════════════

pub use 存在证明 as PresenceProof;
pub use 切片 as Slice;
pub use 时间 as tau;

// 兼容性方法：供英语和俄语模块使用
impl 存在证明 {
    pub fn hash(&self) -> [u8; 32] {
        self.哈希()
    }

    pub fn verify(&self, 当前切片: u64) -> bool {
        self.验证(当前切片)
    }

    pub fn create(钥匙对: &密钥对, 分钟: u64, 切片: u64) -> Self {
        Self::创建(钥匙对, 分钟, 切片)
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
//                                 测试
// ═══════════════════════════════════════════════════════════════════════════════

#[cfg(test)]
mod 测试 {
    use super::*;

    #[test]
    fn 测试存在证明() {
        let 钥 = 密钥对::生成();
        let 证明 = 存在证明::创建(&钥, 100, 10);
        assert!(证明.验证(10));
        assert!(!证明.验证(11));
    }

    #[test]
    fn 测试彩票() {
        let 参与者列表 = vec![
            参与者 { 公钥: [1u8; 32], 池: 节点池::全节点, 权重: 100 },
            参与者 { 公钥: [2u8; 32], 池: 节点池::全节点, 权重: 200 },
            参与者 { 公钥: [3u8; 32], 池: 节点池::验证用户, 权重: 50 },
        ];

        let 彩票 = 确定性彩票::新建(&[0u8; 32], 1, 参与者列表);
        let 胜者 = 彩票.选择胜者();
        assert!(胜者.is_some());
    }
}
