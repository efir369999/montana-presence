# Security Audit: Network Layer DoS & Locking Strategy

**Модель:** Gemini 3 Pro
**Компания:** Google
**Дата:** 08.01.2026 12:00 UTC

---

## 1. Понимание архитектуры

Montana ACP (Atemporal Coordinate Presence) представляет собой уникальную систему распределенного консенсуса, которая отказывается от традиционной парадигмы блокчейна (PoW/PoS) в пользу доказательства присутствия во времени.

Ключевые отличия, которые я усвоил:
- **Нет майнинга:** Консенсус достигается через лотерею среди узлов, доказавших свое присутствие (Presence Proof) в течение временного среза (τ₂).
- **Временные срезы (Slices):** Дискретные позиции в координатной структуре. Порядок определяется криптографической хеш-цепью. Валидность обеспечивается накоплением криптографических доказательств присутствия (подписей) в интервале τ₂.
- **Сетевой слой:** Использует гибридное шифрование Noise (X25519 + Kyber768) для защиты от MITM и скрытия метаданных. Протокол сообщений напоминает Bitcoin (Inv/GetData/Slice), но адаптирован под сущности ACP.
- **Безопасность:** Полагается на криптографию (ML-DSA, Kyber) и строгие лимиты ресурсов для защиты от DoS.

---

## 2. Изученные файлы

| Файл | LOC | Ключевые компоненты |
|------|-----|---------------------|
| `net/protocol.rs` | ~1500 | Основной цикл обработки сообщений, стейт-машина соединений. |
| `net/inventory.rs` | ~600 | Управление инвентарем (TX, Slices, Presence), кеширование, LRU. |
| `net/connection.rs` | ~500 | Управление пирами, баны, лимиты подключений, защита от Sybil. |
| `net/peer.rs` | ~450 | Состояние конкретного пира, трекинг запросов, rate limiting. |
| `net/message.rs` | ~220 | Определения типов сообщений и лимитов размеров. |
| `net/noise.rs` | ~900 | Реализация шифрования Noise handshake (Kyber768). |
| `net/addrman.rs` | ~750 | Менеджер адресов с бакетами (аналог Bitcoin AddrMan). |

---

## 3. Attack Surface

Я определил следующие точки входа для атаки:

1.  **Handshake Process:** Асимметрия вычислительных ресурсов при установлении защищенного соединения (Kyber768).
2.  **Message Processing Loop:** Обработка входящих сообщений `Inv`, `Addr`, `Slice`.
3.  **Locks & Concurrency:** Использование `RwLock` в высоконагруженных путях (Inventory, AddrMan).
4.  **Resource Allocation:** Выделение памяти при десериализации сообщений.

---

## 4. Найденные уязвимости

### [CRITICAL] Async Write Lock Thrashing (Inventory Starvation)

**Файл:** `net/protocol.rs:1015-1020`

**Уязвимый код:**
```rust
// protocol.rs
// 1. Получение списка необходимых хешей (READ lock)
let needed = inventory.read().await.filter_needed(&items);

if !needed.is_empty() {
    for item in &needed {
        // 2. В ЦИКЛЕ берется WRITE lock на каждую итерацию!
        inventory.write().await.request(item, peer.addr);
    }
    // ...
}
```

**Вектор атаки:**
1.  Атакующий генерирует `Inv` сообщение, содержащее 50,000 случайных хешей (`MAX_INV_SIZE`).
2.  Посылает это сообщение узлу.
3.  Узел вызывает `filter_needed`. Так как хеши случайные и новые, все 50,000 попадают в вектор `needed`.
4.  Узел входит в цикл `for item in &needed`.
5.  **Внутри цикла 50,000 раз вызывается `inventory.write().await`.**

**Импакт:** Denial of Service (DoS).
Каждое получение `Write` лока — это дорогая операция синхронизации, которая требует остановки всех `Read` локов. Выполняя это 50,000 раз подряд в цикле, атакующий заставляет планировщик Tokio постоянно переключать контекст и блокировать доступ к `Inventory` для всех остальных пиров.
Если атакующий контролирует 50-100 соединений и шлет такие сообщения непрерывно, инвентарь узла будет перманентно заблокирован на запись/чтение. Честные узлы не смогут запросить реальные блоки или транзакции.

**Сложность:** Низкая. Требуется только установить соединение и спамить валидными по формату сообщениями `Inv`.

**PoC сценарий:**
```rust
// Pseudo-code attacker
let mut items = Vec::new();
for _ in 0..50_000 {
    items.push(InvItem::tx(random_hash())); // Случайные хеши
}
let msg = Message::Inv(items);
send_to_victim(msg).await;
// Повторять с максимально возможной скоростью с множества соединений
```

---

### [MEDIUM] AddrMan Write Lock DoS

**Файл:** `net/protocol.rs:980`

**Уязвимый код:**
```rust
// protocol.rs
// add_many вызывает add(), который делает SipHash вычисления под WRITE локом
let added = addresses.write().await.add_many(to_process, peer.addr);
```

**Вектор атаки:**
1.  Атакующий посылает сообщение `Addr` с 1000 адресами (`MAX_ADDR_MSG_SIZE`).
2.  Узел захватывает эксклюзивную блокировку `addresses`.
3.  Внутри `add_many` происходит цикл по 1000 элементам, для каждого вычисляется SipHash для определения бакета.
4.  В это время остальные компоненты (например, выбор пира для исходящего соединения) заблокированы.

**Импакт:** Временная деградация производительности и задержка в обработке новых соединений.

**Сложность:** Низкая.

---

### [HIGH] Asymmetric Resource Exhaustion (Kyber768 Handshake)

**Файл:** `net/protocol.rs` (listener loop) и `net/noise.rs`

**Описание:**
Монтана использует пост-квантовую криптографию (Kyber768) для хендшейка. Операции инкапсуляции/декапсуляции Kyber значительно тяжелее, чем обычный ECDH.
Сервер принимает TCP соединение и *сразу* запускает задачу `handle_connection`, которая инициирует Noise handshake.

**Вектор атаки:**
1.  Атакующий (имея ботнет/неограниченные ресурсы) открывает тысячи TCP соединений в секунду.
2.  Посылает первый пакет хендшейка (или мусор).
3.  Сервер тратит CPU на криптографию.
4.  `GlobalSubnetLimiter` (в `protocol.rs`) проверяет IP *после* `accept`, но если атакующий имеет распределенный ботнет (разные /16 подсети), он обходит защиту.

**Импакт:** Полная загрузка CPU узла, отказ в обслуживании легитимным клиентам.

**Сложность:** Средняя (требуется ботнет для обхода subnet limiter).

---

## 5. Атаки, которые НЕ работают

1.  **Memory Exhaustion via Message Pre-allocation:**
    Я проверил гипотезу о том, что можно послать заголовок сообщения с длиной 4 МБ, заставив сервер выделить память.
    *Почему не работает:* Чтение происходит внутри `NoiseTransport`, который оперирует фреймами по 64 КБ (`MAX_NOISE_MESSAGE_SIZE`). Десериализация происходит только после полной расшифровки фрейма. Атакующий не может заставить выделить буфер больше 64 КБ за раз.

2.  **Inventory Memory Exhaustion:**
    *Почему не работает:* `Inventory` использует `LruHashSet` с жесткими лимитами (`MAX_HAVE_ENTRIES`, `MAX_RELAY_CACHE_BYTES`). Старые записи вытесняются.

3.  **Peer Memory Exhaustion:**
    *Почему не работает:* Структура `Peer` использует `BoundedInvSet` для трекинга известного инвентаря, ограниченный `MAX_KNOWN_INV` (100k).

---

## 6. Рекомендации

1.  **Исправление Inventory Locking (CRITICAL):**
    Вместо взятия `write` лока в цикле, нужно использовать **batch processing**.
    
    *Было:*
    ```rust
    for item in &needed {
        inventory.write().await.request(item, peer.addr);
    }
    ```
    
    *Стало:*
    Добавить метод `request_many` в `Inventory` и брать лок один раз:
    ```rust
    // protocol.rs
    if !needed.is_empty() {
        inventory.write().await.request_many(needed, peer.addr);
    }
    
    // inventory.rs
    pub fn request_many(&mut self, items: Vec<InvItem>, peer: SocketAddr) {
        for item in items {
            // logic without locking
        }
    }
    ```

2.  **Оптимизация AddrMan:**
    Аналогично инвентарю, убедиться, что `add_many` оптимизирован и не держит лок слишком долго, либо разбить обработку на чанки, давая "подышать" другим читателям.

3.  **Защита Handshake:**
    Внедрить Proof-of-Work (puzzle) *до* начала тяжелого криптографического обмена, если детектируется высокая нагрузка. Либо использовать более агрессивные лимиты на уровне TCP (iptables/bpf) до попадания в Rust-код.

---

## 7. Вердикт

[ ] CRITICAL — есть уязвимости, позволяющие уничтожить сеть
[x] HIGH — есть серьёзные уязвимости (DoS через Inventory Lock + Kyber CPU Exhaustion)
[ ] MEDIUM — есть уязвимости среднего риска
[ ] LOW — только minor issues
[ ] SECURE — уязвимостей не найдено

**Комментарий:** Архитектура в целом надежная (память ограничена, логика AddrMan и Inventory правильная), но реализация многопоточности в обработке сообщений `Inv` содержит критическую ошибку производительности, позволяющую дешево положить узел.

