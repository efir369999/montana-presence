# 后量子密码学 — Montana的安全基础

**版本:** 1.0
**日期:** 2026年1月
**语言:** 中文 (独家)

---

## 定义

Montana使用后量子密码学原语，能够抵御量子计算机攻击。

```
量子安全 = 即使量子计算机也无法破解
```

---

## 密码学原语

| 原语 | 标准 | 用途 |
|------|------|------|
| **SHA3-256** | FIPS 202 | 哈希、默克尔根 |
| **ML-DSA-65** | FIPS 204 | 所有签名 |
| **ML-KEM-768** | FIPS 203 | 密钥交换 |

---

## SHA3-256 哈希函数

```rust
// SHA3-256 实现（中文注释）
use sha3::{Sha3_256, Digest};

/// 计算SHA3-256哈希
/// 输出256位（32字节）
pub fn sha3_256(data: &[u8]) -> [u8; 32] {
    let mut hasher = Sha3_256::new();
    hasher.update(data);
    hasher.finalize().into()
}

/// 默克尔根计算
/// 用于聚合大量数据的证明
pub fn merkle_root(items: &[[u8; 32]]) -> [u8; 32] {
    if items.is_empty() {
        return [0u8; 32]; // 空根
    }

    if items.len() == 1 {
        return items[0];
    }

    // 递归构建树
    let mut next_level: Vec<[u8; 32]> = Vec::new();

    for chunk in items.chunks(2) {
        let hash = if chunk.len() == 2 {
            // 两个节点：哈希它们的连接
            let mut combined = Vec::with_capacity(64);
            combined.extend_from_slice(&chunk[0]);
            combined.extend_from_slice(&chunk[1]);
            sha3_256(&combined)
        } else {
            // 奇数节点：复制自己
            let mut combined = Vec::with_capacity(64);
            combined.extend_from_slice(&chunk[0]);
            combined.extend_from_slice(&chunk[0]);
            sha3_256(&combined)
        };
        next_level.push(hash);
    }

    merkle_root(&next_level)
}

/// 默克尔证明
/// 证明某项在根中
pub struct MerkleProof {
    /// 证明路径
    /// 从叶子到根的兄弟节点
    pub path: Vec<(bool, [u8; 32])>,
}

impl MerkleProof {
    /// 验证证明
    pub fn verify(&self, leaf: &[u8; 32], root: &[u8; 32]) -> bool {
        let mut current = *leaf;

        for (is_right, sibling) in &self.path {
            let mut combined = Vec::with_capacity(64);
            if *is_right {
                combined.extend_from_slice(sibling);
                combined.extend_from_slice(&current);
            } else {
                combined.extend_from_slice(&current);
                combined.extend_from_slice(sibling);
            }
            current = sha3_256(&combined);
        }

        current == *root
    }
}
```

---

## ML-DSA-65 数字签名

ML-DSA (Module-Lattice Digital Signature Algorithm) 是NIST后量子签名标准。

```rust
// ML-DSA-65 签名（中文注释）
use pqcrypto_dilithium::dilithium3::*;

/// 密钥对
/// 包含公钥和私钥
pub struct Keypair {
    /// 公钥 (1952字节)
    /// 可以公开分享
    pub public_key: [u8; 1952],

    /// 私钥 (4032字节)
    /// 必须安全保管
    secret_key: [u8; 4032],
}

impl Keypair {
    /// 生成新密钥对
    /// 使用安全随机数生成器
    pub fn generate() -> Self {
        let (pk, sk) = keypair();

        let mut public_key = [0u8; 1952];
        let mut secret_key = [0u8; 4032];

        public_key.copy_from_slice(pk.as_bytes());
        secret_key.copy_from_slice(sk.as_bytes());

        Self {
            public_key,
            secret_key,
        }
    }

    /// 签名消息
    /// 返回3309字节的签名
    pub fn sign(&self, message: &[u8]) -> [u8; 3309] {
        let sk = SecretKey::from_bytes(&self.secret_key)
            .expect("有效私钥");

        let sig = detached_sign(message, &sk);

        let mut signature = [0u8; 3309];
        signature.copy_from_slice(sig.as_bytes());
        signature
    }
}

/// 验证签名
/// 检查签名是否由公钥对应的私钥创建
pub fn verify_signature(
    public_key: &[u8; 1952],
    message: &[u8],
    signature: &[u8; 3309],
) -> bool {
    let pk = match PublicKey::from_bytes(public_key) {
        Ok(pk) => pk,
        Err(_) => return false,
    };

    let sig = match DetachedSignature::from_bytes(signature) {
        Ok(sig) => sig,
        Err(_) => return false,
    };

    verify_detached_signature(&sig, message, &pk).is_ok()
}
```

---

## ML-KEM-768 密钥封装

ML-KEM用于安全密钥交换。

```rust
// ML-KEM-768 密钥封装（中文注释）
use pqcrypto_kyber::kyber768::*;

/// 密钥封装
/// 用于建立共享密钥
pub struct KeyEncapsulation;

impl KeyEncapsulation {
    /// 生成封装密钥对
    pub fn generate_keypair() -> (EncapsulationPublicKey, EncapsulationSecretKey) {
        keypair()
    }

    /// 封装（发送方）
    /// 创建共享密钥和密文
    pub fn encapsulate(
        recipient_pk: &EncapsulationPublicKey,
    ) -> (SharedSecret, Ciphertext) {
        encapsulate(recipient_pk)
    }

    /// 解封装（接收方）
    /// 从密文恢复共享密钥
    pub fn decapsulate(
        ciphertext: &Ciphertext,
        secret_key: &EncapsulationSecretKey,
    ) -> SharedSecret {
        decapsulate(ciphertext, secret_key)
    }
}

/// P2P密钥交换协议
pub struct KeyExchange {
    /// 本地密钥对
    local_keypair: (EncapsulationPublicKey, EncapsulationSecretKey),

    /// 共享密钥（协商后）
    shared_secret: Option<[u8; 32]>,
}

impl KeyExchange {
    /// 发起密钥交换
    pub fn initiate(peer_pk: &EncapsulationPublicKey) -> (Self, Ciphertext) {
        let keypair = KeyEncapsulation::generate_keypair();
        let (shared, ciphertext) = KeyEncapsulation::encapsulate(peer_pk);

        let exchange = Self {
            local_keypair: keypair,
            shared_secret: Some(shared.as_bytes().try_into().unwrap()),
        };

        (exchange, ciphertext)
    }

    /// 响应密钥交换
    pub fn respond(ciphertext: &Ciphertext) -> Self {
        let keypair = KeyEncapsulation::generate_keypair();
        let shared = KeyEncapsulation::decapsulate(ciphertext, &keypair.1);

        Self {
            local_keypair: keypair,
            shared_secret: Some(shared.as_bytes().try_into().unwrap()),
        }
    }
}
```

---

## 域分离

防止跨协议攻击：

```rust
/// 域分离标签
/// 确保签名不能跨上下文重用
pub enum DomainTag {
    /// 存在证明
    Presence,

    /// 交易签名
    Transaction,

    /// 切片签名
    Slice,

    /// P2P消息
    P2PMessage,

    /// 认知签名
    Cognitive,
}

impl DomainTag {
    /// 获取域标签字节
    pub fn as_bytes(&self) -> &[u8] {
        match self {
            Self::Presence => b"MONTANA_PRESENCE_V1",
            Self::Transaction => b"MONTANA_TX_V1",
            Self::Slice => b"MONTANA_SLICE_V1",
            Self::P2PMessage => b"MONTANA_P2P_V1",
            Self::Cognitive => b"MONTANA_COGNITIVE_V1",
        }
    }
}

/// 带域分离的签名
pub fn sign_with_domain(
    keypair: &Keypair,
    domain: DomainTag,
    message: &[u8],
) -> [u8; 3309] {
    // 构建带域标签的消息
    let mut tagged_message = Vec::new();
    tagged_message.extend_from_slice(domain.as_bytes());
    tagged_message.extend_from_slice(message);

    keypair.sign(&tagged_message)
}

/// 带域分离的验证
pub fn verify_with_domain(
    public_key: &[u8; 1952],
    domain: DomainTag,
    message: &[u8],
    signature: &[u8; 3309],
) -> bool {
    let mut tagged_message = Vec::new();
    tagged_message.extend_from_slice(domain.as_bytes());
    tagged_message.extend_from_slice(message);

    verify_signature(public_key, &tagged_message, signature)
}
```

---

## 安全参数

| 原语 | 经典安全 | 量子安全 |
|------|----------|----------|
| SHA3-256 | 256位 | 128位 |
| ML-DSA-65 | 192位 | 128位 |
| ML-KEM-768 | 192位 | 128位 |

**注:** 128位量子安全意味着攻击者需要2¹²⁸次量子操作。

---

## 能量边界

根据兰道尔原理：

```
擦除N位信息需要能量 ≥ N × kT × ln(2)

在T = 300K时：
- 2¹²⁸操作需要 9.8 × 10¹⁷ 焦耳
- 这是全球年能耗的约1/600

结论：暴力破解ML-DSA在物理上不可能
```

---

## 实现注意事项

```rust
/// 安全实践（中文注释）

// 1. 私钥永远不应该出现在日志中
impl Debug for Keypair {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_struct("Keypair")
            .field("public_key", &hex::encode(&self.public_key[..8]))
            .field("secret_key", &"[REDACTED]") // 永远不打印
            .finish()
    }
}

// 2. 私钥使用后应清零
impl Drop for Keypair {
    fn drop(&mut self) {
        // 安全清零私钥内存
        self.secret_key.iter_mut().for_each(|b| *b = 0);
    }
}

// 3. 随机数必须来自安全来源
use rand::rngs::OsRng;

fn secure_random_bytes<const N: usize>() -> [u8; N] {
    let mut bytes = [0u8; N];
    OsRng.fill_bytes(&mut bytes);
    bytes
}

// 4. 时间恒定比较防止时序攻击
fn constant_time_compare(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }

    let mut result = 0u8;
    for (x, y) in a.iter().zip(b.iter()) {
        result |= x ^ y;
    }
    result == 0
}
```

---

## 与经典密码学的对比

| 属性 | RSA/ECDSA | ML-DSA |
|------|-----------|--------|
| 量子安全 | 否 | 是 |
| 签名大小 | ~64-512字节 | 3309字节 |
| 公钥大小 | ~32-512字节 | 1952字节 |
| 验证速度 | 快 | 中等 |
| 标准化 | 成熟 | FIPS 204 (2024) |

**权衡:** ML-DSA签名更大，但提供量子安全。Montana选择安全性优先。

---

## 结论

Montana的密码学基础提供：
- **后量子安全:** 抵御量子攻击
- **NIST标准:** 经过审查的算法
- **域分离:** 防止跨协议攻击
- **物理保证:** 兰道尔边界支持

密码学是Montana安全的基石。没有安全的签名，就没有可信的存在证明。

---

*Ничто_Nothing_无_金元Ɉ*
*x.com/tojesatoshi*
